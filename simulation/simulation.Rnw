\chapter{Simulation de nombres aléatoires non uniformes}
\label{chap:simulation}

\begin{objectifs}
\item Développer un algorithme de simulation de
  nombres non uniformes à partir de la méthode de l'inverse.
\item Développer un algorithme de simulation de nombres non uniformes
  à partir de la méthode d'acceptation-rejet.
\item Calculer des nombres pseudo-aléatoires non uniformes en
  suivant un algorithme donné.
\item Utiliser les outils de Excel, VBA et R pour la simulation de
  nombres non uniformes.
\end{objectifs}

Habituellement, les applications de la simulation requièrent des
nombres aléatoires provenant non pas d'une distribution $U(0, 1)$,
mais plutôt d'une (ou plusieurs) distribution avec fonction de
répartition $F_X(x)$. Nous devrons donc transformer les nombres
uniformes en des nombres provenant de distributions non-uniformes.

Il existe de très nombreux algorithmes pour générer des nombres
aléatoires de différentes distributions; voir, par exemple,
\cite{Devroye:random:1986}. Nous n'en étudierons que deux en détail,
soit la méthode de l'inverse et la méthode d'acceptation-rejet.
D'autres méthodes populaires en actuariat sont mentionnées à la
\autoref{sec:simulation:autres}.

Plusieurs algorithmes de simulation de nombres non uniformes reposent
sur des résultats de transformations de variables aléatoires. Par
exemple:
\begin{itemize}
\item la somme de $\alpha$ exponentielles est une loi gamma avec
  paramètre de forme $\alpha$ entier;
\item la loi géométrique est la partie entière de l'exponentielle;
\item la loi $F$ est un ratio de deux khi-carré; etc.
\end{itemize}
Le lecteur qui ne serait pas à l'aise avec les notions de
transformation de variables aléatoires trouvera à
l'\autoref{chap:rappels_transformations} des rappels sur les
principales techniques étudiées dans les cours d'analyse probabiliste
et d'analyse statistique.


\section{Méthode de l'inverse}
\label{sec:simulation:inverse}

La méthode de l'inverse repose sur une idée toute simple, soit que
l'on peut transformer des nombres uniformes sur $(0, 1)$ en des
nombres provenant de la distribution avec fonction de répartition
$F_X(x)$ en utilisant le théorème suivant.

\begin{thm}
  \label{thm:simulation:inverse}
  Soit $X$ une variable aléatoire avec fonction de répartition
  $F_X(x)$. Alors
  \begin{displaymath}
    F_X(X) \sim U(0, 1).
  \end{displaymath}
\end{thm}
\begin{proof}
  Soit la transformation $U = F_X(X)$. Alors,
  \begin{align*}
    F_U(u)
    &= \Pr[U \leq u] \\
    &= \Pr[F_X(X) \leq u] \\
    &= \Pr[X \leq F_X^{-1}(u)] \\
    &= F_X(F_X^{-1}(u)) \\
    &= u,
  \end{align*}
  d'où $U \sim U(0, 1)$.
\end{proof}

Par conséquent, si $U \sim U(0, 1)$, alors
\begin{displaymath}
  F_X^{-1}(U) \sim X.
\end{displaymath}
La fonction de répartition inverse, $F_X^{-1}$, est aussi appelée
\emph{fonction de quantile}.

La méthode de l'inverse consiste à choisir un nombre uniformément sur
l'axe des ordonnées d'une fonction de répartition (donc un nombre
entre $0$ et $1$) et à trouver la valeur correspondante sur l'axe des
abscisses telle que donnée par la fonction de quantile. Comme les
valeurs en $x$ seront plus concentrées là où la pente de la fonction
de répartition est la plus grande, et vice versa, la distribution en
abscisse ne sera pas uniforme. Voir la
\autoref{fig:simulation:inverse} pour une représentation
graphique de ce phénomène.

\begin{figure}
  \centering
<<echo=FALSE,fig=TRUE, width=8, height=4>>=
par(mfrow = c(1, 2), mar = c(5, 4, 2, 2))

## Graphique de fonction de répartition
plot(NA, xlim = c(0, 14), ylim = c(0, 1),
     xlab = expression(x), ylab = expression(F[X](x)),
     xaxs="i", yaxs="i")
u <- c(0.3, 0.4, 0.8, 0.9)
x <- qgamma(u, 5, 1)
polygon(c(0, x[1], x[1], x[2], x[2], 0),
        c(u[1], u[1], 0, 0, u[2], u[2]), col="lightblue")
polygon(c(0, x[3], x[3], x[4], x[4], 0),
        c(u[3], u[3], 0, 0, u[4], u[4]), col="lightblue")
curve(pgamma(x, 5, 1), add=TRUE)

## Graphique de la densité
plot(NA, xlim = c(0, 14), ylim = c(0, 0.2),
     xlab = expression(x), ylab = expression(f[X](x)),
     xaxs = "i", yaxs = "i")
xx <- seq(from = x[1], to = x[2], length = 100)
polygon(c(xx[1], xx, xx[100]), c(0, dgamma(xx, 5, 1), 0), col = "lightblue")
xx <- seq(from = x[3], to = x[4], length = 100)
polygon(c(xx[1], xx, xx[100]), c(0, dgamma(xx, 5, 1), 0), col = "lightblue")
curve(dgamma(x, 5, 1), xlim = c(0, 14), add=TRUE)
@
  \caption{Représentation graphique de la méthode de l'inverse. À
    intervalles égaux en ordonnée correspondent des intervalles
    différents en abscisse selon la forme de la distribution. La
    fonction de répartition à gauche correspond à la densité de droite.}
  \label{fig:simulation:inverse}
\end{figure}

La méthode de l'inverse en est une bonne si la fonction de quantile
est facile à calculer. S'il n'existe pas de forme explicite pour
$F_X^{-1}(\cdot)$, résoudre numériquement
\begin{displaymath}
  F_X(x) - u = 0
\end{displaymath}
peut s'avérer aussi efficace que bien d'autres méthodes.

\begin{rem}
  Dans Excel (et VBA), on doit nécessairement utiliser la méthode de
  l'inverse. Plusieurs fonctions de quantiles sont disponibles
  (\autoref{sec:simulation:excel_et_al}).
\end{rem}


\subsection{Distributions continues}
\label{sec:simulation:inverse:continues}

La méthode de l'inverse est, en principe du moins, simple à utiliser
avec les distributions continues: il suffit de connaître la fonction
de quantile et de l'appliquer à des nombres uniformes pour obtenir des
nombres de la distribution souhaitée.

Dans les faits, il y a peu de lois de probabilité continues dont la
fonction de répartition est simple à inverser (exponentielle, Pareto,
Weibull, ...) Il faut parfois utiliser d'autres méthodes.

\begin{exemple}
  On veut obtenir un échantillon aléatoire d'une distribution
  exponentielle de paramètre $\lambda$ avec fonction de densité de
  probabilité
  \begin{align*}
    f(x)
    &= \lambda e^{-\lambda x}, \quad x > 0 \\
    \intertext{et fonction de répartition}
    F(x)
    &= 1 - e^{-\lambda x}, \quad x > 0.
  \end{align*}
  Or,
  \begin{displaymath}
    F^{-1}(u) = - \frac{1}{\lambda} \ln (1 - u),
  \end{displaymath}
  donc
  \begin{displaymath}
    X = - \frac{1}{\lambda} \ln (1 - U) \sim \text{Exponentielle}(\lambda),
  \end{displaymath}
  où $U \sim U(0, 1)$. En fait, puisque $U \sim U(0, 1)
  \Leftrightarrow 1 - U \sim U(0, 1)$, on peut se contenter de la
  relation
  \begin{displaymath}
    X = - \frac{1}{\lambda} \ln U \sim \text{Exponentielle}(\lambda).
  \end{displaymath}
  Par conséquent, l'algorithme pour simuler des nombres provenant
  d'une exponentielle de paramètre $\lambda$ est:
  \begin{enumerate}
  \item Obtenir un nombre $u$ d'une $U(0, 1)$;
  \item Poser $x = - \lambda^{-1} \ln u$.
  \end{enumerate}

  \begin{gotoR}
    Exécuter le code informatique R de la
    \autoref{sec:simulation:code} correspondant à cet exemple
    pour une illustration de l'algorithme ci-dessus.
  \end{gotoR}
  \qed
\end{exemple}


\subsection{Distributions discrètes}
\label{sec:simulation:inverse:discretes}

On peut aussi utiliser la méthode de l'inverse avec les distributions
discrètes. Cependant, puisque la fonction de répartition comporte des
sauts, son inverse n'existe pas formellement. Par conséquent, il
n'existe pas de solution de $u = F_X(x)$ pour certaines valeurs de
$u$, ou alors une infinité de solutions.

Supposons une distribution avec un saut en $x_0$ et
\begin{align*}
  F_X(x_0^-) &= a \\
  F_X(x_0) &= b > a.
\end{align*}
Si $a < u < b$, on pose $x = x_0$. Ainsi, $x_0$ sera simulé dans une
proportion $b - a$ du temps, ce qui correspond à $\Pr[X = x_0]$. Voir
la \autoref{fig:simulation:discrete} pour une illustration.

\begin{figure}
  \centering
<<echo=FALSE, fig=TRUE>>=
set.seed(1)
x <- rbinom(1000, 4, 0.6)
Fn <- ecdf(x)
plot(Fn, xlim = c(0, 5), ylab="F(x)", main = "")
polygon(c(par("usr")[1], 2, 2, par("usr")[1]),
        Fn(c(1, 1, 2, 2)), col = "lightblue", border = NA)
plot(Fn, add = TRUE)
u <- runif(1, Fn(1), Fn(2))
arrows(par("usr")[1], u, 2, u, length = 0.125)
segments(2, par("usr")[3], 2, Fn(2), lty = 2)
axis(2)
@
  \caption{Illustration de la méthode de l'inverse pour une distribution
   discrète. Tout nombre uniforme tiré dans la zone colorée est
   converti en la même valeur, ce qui correspond à la probabilité
   d'obtenir cette valeur (la hauteur du saut).}
  \label{fig:simulation:discrete}
\end{figure}

Que faire si $u = a$ ou $u = b$? On prend la plus grande valeur de
l'intervalle où $F_X(x)$ est constante:
\begin{align*}
  u = a  &\Rightarrow x = x_0 \\
  u = b  &\Rightarrow x = x_1.
\end{align*}
On procède ainsi parce que plusieurs générateurs produisent des
nombres uniformes sur $[0, 1)$.

\begin{exemple}
  \label{exemple:simulation:mixte}
  Soit $X$ une variable aléatoire avec fonction de densité de probabilité
  \begin{displaymath}
    f(x) =
    \begin{cases}
      0,5, & 0 \leq x < 1 \\
      0,   & 1 \leq x < 2 \\
      0,5, & 2 \leq x < 3.
    \end{cases}
  \end{displaymath}
  On a une variable aléatoire \emph{mixte} (en partie continue et en
  partie continue) dont la fonction de répartition est
  \begin{displaymath}
    F(x) =
    \begin{cases}
      0,5x, & 0 \leq x < 1 \\
      0,5   & 1 \leq x < 2 \\
      0,5x - 0,5, & 2 \leq x < 3.
    \end{cases}
  \end{displaymath}
  \enlargethispage{5mm}
  (Voir la \autoref{fig:simulation:mixte}.)

  \begin{figure}
    \centering
<<echo=FALSE,fig=TRUE, width=8, height=4>>=
par(mfrow = c(1, 2), mar = c(5, 4, 2, 2))
plot(NA, xlim = c(0, 3), ylim = c(0, 1),
     xlab = expression(x), ylab = expression(f[X](x)),
     xaxt = "n", yaxt = "n")
points(c(0, 1), rep(0.5, 2), type = "o", pch = c(19, NA))
points(c(1, 2), rep(0, 2), type = "o", pch = c(19, NA))
points(c(2, 3), rep(0.5, 2), type = "o", pch = c(19, NA))
axis(1, at = 0:3)
axis(2, at = 0:2/2)
plot(0:3, c(0, 0.5, 0.5, 1), type = "o", pch = 19,
     xlab = expression(x), ylab = expression(F[X](x)),
     xaxt = "n", yaxt = "n")
axis(1, at = 0:3)
axis(2, at = 0:2/2)
@
    \caption{Fonction de densité de probabilité (gauche) et fonction de
      répartition (droite) de l'\autoref{exemple:simulation:mixte}}
    \label{fig:simulation:mixte}
  \end{figure}

  Par conséquent, un algorithme pour simuler des nombres aléatoires de
  cette distribution est:
  \begin{enumerate}
  \item Obtenir un nombre $u$ d'une loi $U(0, 1)$.
  \item Poser
    \begin{displaymath}
      x =
      \begin{cases}
        2u,    & \text{si } 0 \leq u < 1 \\
        2,     & \text{si } u = 0,5 \\
        2u + 1 & \text{si } 0,5 < u < 1.
      \end{cases}
    \end{displaymath}
  \end{enumerate}
  \begin{gotoR}
    Une mise en {\oe}uvre en R de l'algorithme ci-dessus est présentée
    dans le code informatique de la
    \autoref{sec:simulation:code}.
  \end{gotoR}
  \qed
\end{exemple}

\begin{exemple}
  On veut simuler des observations d'une distribution binomiale de
  paramètres $n$ et $\theta$. On pourrait, pour chaque $x$ simulé,
  faire $n$ expériences de Bernoulli et compter le nombre de succès.
  Par la méthode de l'inverse pour la loi de Bernoulli, on a un succès
  si $u \leq \theta$. Par conséquent, un algorithme serait:
  \begin{enumerate}
  \item Simuler $n$ nombres uniformes indépendants $u_1, \dots, u_n$
    d'une loi $U(0, 1)$.
  \item Poser
    \begin{displaymath}
      x = \sum_{i = 1}^n I\{u_i \leq \theta\}.
    \end{displaymath}
  \end{enumerate}
  Cette technique requiert toutefois de simuler $n$ nombres uniformes
  pour chaque valeur de $x$.

  Il est plus efficace d'utiliser la méthode de l'inverse directement
  avec la distribution binomiale. Par exemple, si $n = 4$ et $\theta =
  0,5$, on a que
  \begin{align*}
    \Pr[X = x]
    &=
    \begin{cases}
      0,0625, & x = 0 \\
      0,25,   & x = 1 \\
      0,375,  & x = 2 \\
      0,25,   & x = 3 \\
      0,0625, & x = 4
    \end{cases} \\
    \intertext{et}
    \Pr[X \leq x]
    &=
    \begin{cases}
      0,      & x < 0 \\
      0,0625, & 0 \leq x < 1 \\
      0,3125, & 1 \leq x < 2 \\
      0,6875, & 2 \leq x < 3 \\
      0,9375, & 3 \leq x < 4 \\
      1,      & x \geq 4,
    \end{cases}
  \end{align*}
  d'où l'algorithme suivant:
  \begin{enumerate}
  \item Simuler un nombre $u$ d'une distribution $U(0, 1)$.
  \item Déterminer $x$ selon le tableau suivant:
    \begin{center}
      \begin{tabular}{lc}
        \toprule
        $u$ dans l'intervalle & Valeur de $x$ \\
        \midrule
        $[0, 0,0625)$         & $0$ \\
        $[0,0625, 0,3125)$    & $1$ \\
        $[0,3125, 0,6875)$    & $2$ \\
        $[0,6875, 0,9375)$    & $3$ \\
        $[0,9375, 1)$         & $4$ \\
        \bottomrule
      \end{tabular}
    \end{center}
  \end{enumerate}
  \qed
\end{exemple}

\begin{rem}
  La méthode de l'inverse pour les distributions discrètes à support
  fini est facile à mettre en {\oe}uvre dans Excel à l'aide de la
  fonction \texttt{RECHERCHEV()}.
\end{rem}


\section{Méthode acceptation-rejet}

Supposons qu'il est compliqué de simuler des réalisations de la
variable aléatoire $X$ avec fonction de densité de probabilité
$f_X(x)$. Si on peut trouver une variable aléatoire $Y$ avec fonction
de densité de probabilité $g_Y(x)$ pour laquelle la simulation est
simple (uniforme, triangle, exponentielle, etc.) et qu'il est possible
d'«envelopper» la densité $f$ par un multiple de $g$, c'est-à-dire que
\begin{displaymath}
  c g_Y(x) \geq f_X(x)
\end{displaymath}
pour tout $x$, alors on a l'algorithme d'acceptation-rejet suivant:
\begin{enumerate}
\item Générer une réalisation $y$ de la variable aléatoire $Y$ avec
  fonction de densité de probabilité $g_Y(\cdot)$.
\item Générer un nombre $u$ d'une $U(0, 1)$.
\item Si
  \begin{displaymath}
    u \leq \frac{f_X(y)}{c g_Y(y)},
  \end{displaymath}
  poser $x = y$. Sinon, retourner à l'étape 1.
\end{enumerate}

\begin{rem}
  Puisque, par définition, l'aire sous les densités $f$ et $g$ vaut $1$
  dans les deux cas on ne peut avoir $c g_Y(x) \geq f_X(x)$ pour tout
  $x$ que si $c > 1$.
\end{rem}

L'idée de la \capsule{méthode d'acceptation-rejet} consiste à accepter
la «bonne proportion» des réalisations de $Y$ comme provenant de $X$.
Dans l'illustration de la
\autoref{fig:simulation:acceptation-rejet}, la densité $f$ à
support fini est facilement enveloppée par un rectangle. Un nombre $y$
simulé de cette distribution (à toutes fins pratiques une uniforme,
ici) est accepté comme provenant de $f$ dans une proportion
correspondant au ratio entre la valeur de $f_X(y)$ (les segments verts
dans la figure) et la valeur de $c g_Y(y)$ (les segments bleus). À
l'inverse, le nombre $y$ est rejeté selon le ratio de la longueur d'un
segment rouge sur celle d'un segment bleu. On voit donc que certaines
valeurs $y$ seront rejetées plus souvent que d'autres.

\begin{figure}
  \centering
<<echo=FALSE, fig=TRUE>>=
plot(NA, xlim = c(0, 1), ylim = c(0, 2), xlab = "y", ylab = "f(y)")
m <- dbeta(2/3, 3, 2)
x <- c(0.22, 0.58, 0.83)
eps <- eps <- 40E-4
segments(x - eps, 0, x - eps, dbeta(x, 3, 2), col = "green3", lwd = 3)
segments(x - eps, dbeta(x, 3, 2), x - eps, m, col = "red3", lwd = 3)
segments(x + eps, 0, x + eps, m, col = "blue3", lwd = 3)
curve(dbeta(x, 3, 2), xlim = c(0, 1), add = TRUE, lwd = 2)
segments(0, 0, 0, m, col = "blue3")
segments(1, 0, 1, m, col = "blue3")
segments(0, m, 1, m, col = "blue3", lwd = 3)
text(0.1, m + 0.08, "c g(y)")
@
  \caption{Illustration de la méthode acceptation-rejet}
  \label{fig:simulation:acceptation-rejet}
\end{figure}

\begin{rems}
  \begin{enumerate}
  \item La principale difficulté avec cette méthode consiste à trouver
    la fonction enveloppante.
  \item Évidemment, plus $c g_Y(x)$ est près de $f_X(x)$, plus
    l'algorithme est performant puisque l'on rejette alors moins de
    valeurs.
  \end{enumerate}
\end{rems}

\begin{exemple}
  \label{exemple:simulation:beta}
  Soit $X \sim \text{Bêta}(3, 2)$. On a
  \begin{align*}
    f_X(x)
    &= \frac{\Gamma(5)}{\Gamma(3) \Gamma(2)}\,
    x^{3 - 1} (1 - x)^{2 - 1} \\
    &= 12 x^2 (1 - x), \quad 0 < x < 1.
  \end{align*}
  On peut inscrire la densité $f(x)$ dans un triangle aux
  caractéristiques suivantes (voir la \autoref{fig:simulation:beta-triangle}):
  \begin{figure}
    \centering
<<echo=FALSE, fig=TRUE>>=
curve(dbeta(x, 3, 2), xlim = c(0, 1), ylim = c(0, 2.5), lwd = 2)
lines(c(0, 0.8, 1), c(0, 2.4, 0), lwd = 2, col = "blue3")
segments(0.5, 0, 0.5, 1.5, lty = 2)
segments(0.8, 0, 0.8, 2.4, lty = 2)
axis(side = 1, at = 0.5)
@
    \caption{Fonction de densité de probabilité d'une loi Bêta$(3, 2)$
      enveloppée d'un triangle}
    \label{fig:simulation:beta-triangle}
  \end{figure}
  \begin{itemize}
  \item arête gauche
    \begin{enumerate}
    \item passe par $(0, 0)$, donc de la forme $y = mx$;
    \item $y = mx$ est tangent à $f(x)$, donc la pente $m$ est telle
      que l'équation $mx = 12 x^2 (1 - x)$ a une seule racine autre
      que 0, d'où $y = 3 x$;
    \end{enumerate}
  \item arête droite
    \begin{enumerate}
    \item passe par $(1, 0)$, donc de la forme $y = mx + b$ avec $m +
      b = 0$;
    \item pente égale à la pente de $f(x)$ en $x = 1$, d'où $y = 12 -
      12 x$.
    \end{enumerate}
  \end{itemize}
  Par conséquent,
  \begin{displaymath}
    c g_Y(x) =
    \begin{cases}
      3x,       & 0 < x < 0,8 \\
      12 - 12 x, & 0,8 < x < 1.
    \end{cases}
  \end{displaymath}
  Or, l'aire du triangle est
  \begin{displaymath}
    \frac{(1) c g_Y(0,8)}{2} = \frac{(1)(2,4)}{2} = 1,2,
  \end{displaymath}
  d'où $c = 1,2$. Ainsi,
  \begin{align*}
    g_Y(x)
    &=
    \begin{cases}
      2,5 x,     & 0 < x < 0,8 \\
      10 - 10 x, & 0,8 < x < 1,
    \end{cases} \\
    \intertext{et}
    G_Y(x)
    &=
    \begin{cases}
      1,25 x^2,          & 0 < x < 0,8 \\
      -5 x^2 + 10 x - 4, & 0,8 < x < 1,
    \end{cases} \\
    \intertext{d'où}
    G_Y^{-1}(y)
    &=
    \begin{cases}
      \sqrt{0,8 y},           & 0 < y < 0,8 \\
      1 - \sqrt{0,2 - 0,2 y}, & 0,8 < y < 1.
    \end{cases}
  \end{align*}
  On a donc l'algorithme suivant:
  \begin{enumerate}
  \item Simuler deux nombres $u_1$ et $u_2$ d'une $U(0, 1)$.
  \item Poser $y = G_Y^{-1}(u_1)$.
  \item Si
    \begin{displaymath}
      u_2 \leq \frac{f_X(y)}{1,2 g_Y(y)} \Leftrightarrow
      1,2 g_Y(y) u_2 \leq f_X(y),
    \end{displaymath}
    alors poser $x = y$. Sinon, retourner à l'étape 1.
  \end{enumerate}
  \qed
\end{exemple}



\section{Fonctions de simulation de variables aléatoires dans Excel,
  VBA et \textsf{R}}
\label{sec:simulation:excel_et_al}

Il est important de savoir simuler des valeurs d'une variable
aléatoire quelconque à partir de la méthode de l'inverse ou d'un autre
algorithme, surtout si la distribution de la variable aléatoire est
peu usitée. Néanmoins, les différents outils statistiques à notre
disposition nous fournissent en général la majorité des fonctions de
simulation de variables aléatoires dont on peut avoir besoin pour un
usage quotidien.


\subsection{Excel et VBA}

Tel que mentionné à la section 3.1, il faut généralement utiliser la
méthode de l'inverse pour simuler des observations de lois de
probabilité dans Excel. Cette procédure est facilitée par le fait
qu'il existe des fonctions Excel pour calculer la fonction de
répartition inverse (ou fonction de quantile) des lois les plus
courantes.

Ainsi, on trouvera dans Excel la fonction de densité de probabilité
(lois continues) ou la fonction de masse de probabilité (lois
discrètes) et/ou la fonction de répartition et, dans certains cas
seulement, la fonction de quantile des lois de probabilité présentées
au \autoref{tab:excel}. Les noms anglais des fonctions ont été
modifiés pour être standardisés dans Excel~2010. On remarquera que les
traducteurs français ont omis de faire de même.

\begin{table}[t]
  \centering
  \begin{tabularx}{\linewidth}{lp{17ex}X}
    \toprule
    Loi de probabilité &
    Fonctions Excel \newline (nom anglais) &
    Fonctions Excel \newline (nom français) \\
    \midrule
    Bêta &
    \code{BETA.DIST} \newline \code{BETA.INV} &
    \code{LOI.BETA.N} \newline \code{BETA.INVERSE.N} \\
    Binomiale &
    \code{BINOM.DIST} \newline \code{BINOM.INV} &
    \code{LOI.BINOMALE.N} \newline \code{LOI.BINOMIALE.INVERSE} \\
    Binomiale négative &
    \code{NEGBINOM.DIST} &
    \code{LOI.BINOMIALE.NEG.N} \\
    Exponentielle &
    \code{EXPON.DIST} &
    \code{LOI.EXPONENTIELLE.N} \\
    \emph{F} (Fisher) &
    \code{F.DIST} \newline \code{F.INV} &
    \code{LOI.F.N} \newline \code{INVERSE.LOI.F.N} \\
    Gamma &
    \code{GAMMA.DIST} \newline \code{GAMMA.INV} &
    \code{LOI.GAMMA.N} \newline \code{LOI.GAMMA.INVERSE.N} \\
    Hypergéométrique &
    \code{HYPGEOM.DIST} &
    \code{LOI.HYPERGEOMETRIQUE.N} \\
    Khi carré &
    \code{CHISQ.DIST} \newline \code{CHISQ.INV} &
    \code{LOI.KHIDEUX} \newline \code{LOI.KHIDEUX.INVERSE} \\
    Log-normale &
    \code{LOGNORM.DIST} \newline \code{LOGNORM.INV} &
    \code{LOI.LOGNORMALE.N} \newline \code{LOI.LOGNORMALE.INVERSE.N} \\
    Normale &
    \code{NORM.DIST} \newline
    \code{NORM.INV} \newline
    \code{NORM.S.DIST} \newline
    \code{NORM.S.INV} &
    \code{LOI.NORMALE.N} \newline
    \code{LOI.NORMALE.INVERSE.N} \newline
    \code{LOI.NORMALE.STANDARD.N} \newline
    \code{LOI.NORMALE.STANDARD.INVERSE.N} \\
    Poisson &
    \code{POISSON.DIST} &
    \code{LOI.POISSON.N} \\
    \emph{t} (Student) &
    \code{T.DIST} \newline \code{T.INV} &
    \code{LOI.STUDENT.N} \newline \code{LOI.STUDENT.INVERSE.N} \\
    Weibull &
    \code{WEIBULL.DIST} &
    \code{LOI.WEIBULL.N} \\
    \bottomrule
  \end{tabularx}
  \caption{Liste des fonctions relatives à des lois de probabilité
    dans Excel 2010.}
  \label{tab:excel}
\end{table}

Aucune fonction statistique n'existe dans VBA. On fera donc appel aux
fonctions de Excel en préfixant les noms de fonctions \emph{anglais}
du \autoref{tab:excel} de la propriété \code{WorksheetFunction}.
En utilisant une structure
\begin{verbatim}
With WorksheetFunction
    ...
End With
\end{verbatim}
dans une routine VBA, il est également possible accéder directement
aux fonctions Excel en les préfixant seulement d'un point.


\subsection{R}

\input{rng-lois}

\begin{gotoR}
  Le code informatique R de la \autoref{sec:simulation:code}
  contient des exemples plus détaillés d'utilisation des fonctions
  mentionnées ci-dessus.
\end{gotoR}



\section{Autres techniques de simulation}
\label{sec:simulation:autres}

Il existe plusieurs autres algorithmes de simulation de loi non
uniformes, certains beaucoup plus élaborés que d'autres. Nous
n'irons pas plus loin dans ce sujet dans ce cours, sinon pour
mentionner deux autres techniques simples qui sont souvent employées
en actuariat:
\begin{enumerate}
\item les mélanges de distributions continus et discrets;
\item la convolution de variables aléatoires.
\end{enumerate}

\begin{gotoR}
  Ces techniques sont présentées et illustrées à même le code
  informatique R de la \autoref{sec:simulation:code}.
\end{gotoR}

En terminant, mentionnons que l'\autoref{planification} propose
quelques trucs pour bien planifier une étude de simulation en R.



\section{Code informatique}
\label{sec:simulation:code}

\lstinputlisting[firstline=3]{simulation.R}

\vfill

\input{exercices-simulation}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "methodes_numeriques-partie_2"
%%% coding: utf-8
%%% End:
