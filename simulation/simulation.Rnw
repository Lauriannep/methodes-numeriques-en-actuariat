\chapter{Simulation de nombres aléatoires non uniformes}
\label{chap:simulation}

\begin{objectifs}
\item Développer un algorithme de simulation de
  nombres non uniformes à partir de la méthode de l'inverse.
\item Développer un algorithme de simulation de nombres non uniformes
  à partir de la méthode d'acceptation-rejet.
\item Calculer des nombres pseudo-aléatoires non uniformes en
  suivant un algorithme donné.
\item Utiliser les outils de Excel, VBA et R pour la simulation de
  nombres non uniformes.
\end{objectifs}

Habituellement, les applications de la simulation requièrent des
nombres aléatoires provenant non pas d'une distribution $U(0, 1)$,
mais plutôt d'une (ou plusieurs) distribution avec fonction de
répartition $F_X(x)$. On doit donc transformer les nombres
uniformes en des nombres provenant de distributions non-uniformes.

Il existe de très nombreux algorithmes pour générer des nombres
aléatoires de différentes distributions; voir, par exemple,
\cite{Devroye:random:1986}. Nous n'en étudierons que deux en détail,
soit la méthode de l'inverse et la méthode d'acceptation-rejet.
D'autres méthodes populaires en actuariat sont mentionnées à la
\autoref{sec:simulation:autres}.

Plusieurs algorithmes de simulation de nombres non uniformes reposent
sur des résultats de transformations de variables aléatoires. Par
exemple:
\begin{itemize}
\item la somme de $\alpha$ exponentielles est une loi gamma avec
  paramètre de forme $\alpha$ entier;
\item la loi géométrique est la partie entière de l'exponentielle;
\item la loi $F$ est un ratio de deux khi-carré; etc.
\end{itemize}
Le lecteur qui ne serait pas à l'aise avec les notions de
transformation de variables aléatoires trouvera à
l'\autoref{chap:rappels_transformations} des rappels sur les
principales techniques étudiées dans les cours d'analyse probabiliste
et d'analyse statistique.

\begin{prob-enonce}
  Au chapitre précédent, le problème présenté consistait à
  calculer par simulation la probabilité que l'enveloppe
  convexe d'un ensemble de quatre points forme un triangle
  lorsque ceux-ci sont distribués uniformément sur un plan
  \emph{carré} de longueur et de largeur 1.

  Cette fois, vous devez vérifier par simulation que lorsque
  la région $R$ est un \emph{disque}, et que les quatre points
  sont distribués uniformément sur la région, la probabilité
  que l'enveloppe convexe forme un triangle est
  $\frac{35}{12 \pi^2} \approx 0,29552$.
\end{prob-enonce}

\section{Méthode de l'inverse}
\label{sec:simulation:inverse}

La méthode de l'inverse repose sur une idée toute simple, soit que
l'on peut transformer des nombres uniformes sur $(0, 1)$ en des
nombres provenant de la distribution avec fonction de répartition
$F_X(x)$ en utilisant le théorème suivant.

\begin{thm}
  \label{thm:simulation:inverse}
  Soit $X$ une variable aléatoire avec fonction de répartition
  $F_X(x)$. Alors
  \begin{displaymath}
    F_X(X) \sim U(0, 1).
  \end{displaymath}
\end{thm}
\begin{proof}
  Soit la transformation $U = F_X(X)$. Alors,
  \begin{align*}
    F_U(u)
    &= \Pr[U \leq u] \\
    &= \Pr[F_X(X) \leq u] \\
    &= \Pr[X \leq F_X^{-1}(u)] \\
    &= F_X(F_X^{-1}(u)) \\
    &= u,
  \end{align*}
  d'où $U \sim U(0, 1)$.
\end{proof}

Par conséquent, si $U \sim U(0, 1)$, alors
\begin{displaymath}
  F_X^{-1}(U) \sim X.
\end{displaymath}
La fonction de répartition inverse, $F_X^{-1}$, est aussi appelée
\emph{fonction de quantile}.

La méthode de l'inverse consiste à choisir un nombre uniformément sur
l'axe des ordonnées d'une fonction de répartition (donc un nombre
entre $0$ et $1$) et à trouver la valeur correspondante sur l'axe des
abscisses telle que donnée par la fonction de quantile. Comme les
valeurs en $x$ seront plus concentrées là où la pente de la fonction
de répartition est la plus grande, et vice versa, la distribution en
abscisse ne sera pas uniforme. Voir la
\autoref{fig:simulation:inverse} pour une représentation
graphique de ce phénomène.

\begin{figure}
  \centering
<<echo=FALSE,fig=TRUE, width=8, height=4>>=
par(mfrow = c(1, 2), mar = c(5, 4, 2, 2))

## Graphique de fonction de répartition
plot(NA, xlim = c(0, 14), ylim = c(0, 1),
     xlab = expression(x), ylab = expression(F[X](x)),
     xaxs="i", yaxs="i")
u <- c(0.3, 0.4, 0.8, 0.9)
x <- qgamma(u, 5, 1)
polygon(c(0, x[1], x[1], x[2], x[2], 0),
        c(u[1], u[1], 0, 0, u[2], u[2]), col="lightblue")
polygon(c(0, x[3], x[3], x[4], x[4], 0),
        c(u[3], u[3], 0, 0, u[4], u[4]), col="lightblue")
curve(pgamma(x, 5, 1), add=TRUE)

## Graphique de la densité
plot(NA, xlim = c(0, 14), ylim = c(0, 0.2),
     xlab = expression(x), ylab = expression(f[X](x)),
     xaxs = "i", yaxs = "i")
xx <- seq(from = x[1], to = x[2], length = 100)
polygon(c(xx[1], xx, xx[100]), c(0, dgamma(xx, 5, 1), 0), col = "lightblue")
xx <- seq(from = x[3], to = x[4], length = 100)
polygon(c(xx[1], xx, xx[100]), c(0, dgamma(xx, 5, 1), 0), col = "lightblue")
curve(dgamma(x, 5, 1), xlim = c(0, 14), add=TRUE)
@
  \caption{Représentation graphique de la méthode de l'inverse. À
    des intervalles égaux en ordonnée correspondent des intervalles
    différents en abscisse selon la forme de la distribution. La
    fonction de répartition à gauche correspond à la densité de droite.}
  \label{fig:simulation:inverse}
\end{figure}

La méthode de l'inverse en est une bonne si la fonction de quantile
est facile à calculer. S'il n'existe pas de forme explicite pour
$F_X^{-1}(\cdot)$, résoudre numériquement
\begin{displaymath}
  F_X(x) - u = 0
\end{displaymath}
peut s'avérer aussi efficace que bien d'autres méthodes.

\begin{rem}
  Dans Excel (et VBA), on doit nécessairement utiliser la méthode de
  l'inverse. Plusieurs fonctions de quantiles sont disponibles
  (\autoref{sec:simulation:excel_et_al}).
\end{rem}


\subsection{Distributions continues}
\label{sec:simulation:inverse:continues}

La méthode de l'inverse est, en principe du moins, simple à utiliser
avec les distributions continues: il suffit de connaître la fonction
de quantile et de l'appliquer à des nombres uniformes pour obtenir des
nombres de la distribution souhaitée.

Dans les faits, il y a peu de lois de probabilité continues dont la
fonction de répartition est simple à inverser (exponentielle, Pareto,
Weibull). Il faut parfois utiliser d'autres méthodes.

\begin{exemple}
  On veut obtenir un échantillon aléatoire d'une distribution
  exponentielle de paramètre $\lambda$ avec fonction de densité de
  probabilité
  \begin{align*}
    f(x)
    &= \lambda e^{-\lambda x}, \quad x > 0 \\
    \intertext{et fonction de répartition}
    F(x)
    &= 1 - e^{-\lambda x}, \quad x > 0.
  \end{align*}
  Or,
  \begin{displaymath}
    F^{-1}(u) = - \frac{1}{\lambda} \ln (1 - u),
  \end{displaymath}
  donc
  \begin{displaymath}
    X = - \frac{1}{\lambda} \ln (1 - U) \sim \text{Exponentielle}(\lambda),
  \end{displaymath}
  où $U \sim U(0, 1)$. En fait, puisque $U \sim U(0, 1)
  \Leftrightarrow 1 - U \sim U(0, 1)$, on peut se contenter de la
  relation
  \begin{displaymath}
    X = - \frac{1}{\lambda} \ln U \sim \text{Exponentielle}(\lambda).
  \end{displaymath}
  Par conséquent, l'algorithme pour simuler des nombres provenant
  d'une exponentielle de paramètre $\lambda$ est:
  \begin{enumerate}
  \item Obtenir un nombre $u$ d'une $U(0, 1)$;
  \item Poser $x = - \lambda^{-1} \ln u$.
  \end{enumerate}

  \begin{gotoR}
    Exécuter le code informatique R de la
    \autoref{sec:simulation:code} correspondant à cet exemple
    pour une illustration de l'algorithme ci-dessus.
  \end{gotoR}
  \qed
\end{exemple}


\subsection{Distributions discrètes}
\label{sec:simulation:inverse:discretes}

On peut aussi utiliser la méthode de l'inverse avec les distributions
discrètes. Cependant, puisque la fonction de répartition comporte des
sauts, son inverse n'existe pas formellement. Par conséquent, il
n'existe pas de solution de $u = F_X(x)$ pour certaines valeurs de
$u$, ou alors une infinité de solutions.

Supposons une distribution avec un saut en $x_0$ et
\begin{align*}
  F_X(x_0^-) &= a \\
  F_X(x_0) &= b > a.
\end{align*}
Si $a < u < b$, on pose $x = x_0$. Ainsi, $x_0$ sera simulé dans une
proportion $b - a$ du temps, ce qui correspond à $\Pr[X = x_0]$. Voir
la \autoref{fig:simulation:discrete} pour une illustration.

\begin{figure}
  \centering
<<echo=FALSE, fig=TRUE>>=
set.seed(1)
x <- rbinom(1000, 4, 0.6)
Fn <- ecdf(x)
plot(Fn, xlim = c(0, 5), ylab="F(x)", main = "")
polygon(c(par("usr")[1], 2, 2, par("usr")[1]),
        Fn(c(1, 1, 2, 2)), col = "lightblue", border = NA)
plot(Fn, add = TRUE)
u <- runif(1, Fn(1), Fn(2))
arrows(par("usr")[1], u, 2, u, length = 0.125)
segments(2, par("usr")[3], 2, Fn(2), lty = 2)
axis(2)
@
  \caption{Illustration de la méthode de l'inverse pour une distribution
   discrète. Tout nombre uniforme tiré dans la zone colorée est
   converti en la même valeur, ce qui correspond à la probabilité
   d'obtenir cette valeur (la hauteur du saut).}
  \label{fig:simulation:discrete}
\end{figure}

Que faire si $u = a$ ou $u = b$? On prend la plus grande valeur de
l'intervalle où $F_X(x)$ est constante:
\begin{align*}
  u = a  &\Rightarrow x = x_0 \\
  u = b  &\Rightarrow x = x_1.
\end{align*}
On procède ainsi parce que plusieurs générateurs produisent des
nombres uniformes sur $[0, 1)$.

\begin{exemple}
  \label{exemple:simulation:mixte}
  Soit $X$ une variable aléatoire avec fonction de densité de probabilité
  \begin{displaymath}
    f(x) =
    \begin{cases}
      0,5, & 0 \leq x < 1 \\
      0,   & 1 \leq x < 2 \\
      0,5, & 2 \leq x < 3.
    \end{cases}
  \end{displaymath}
  On a une variable aléatoire \emph{mixte} (en partie continue et en
  partie continue) dont la fonction de répartition est
  \begin{displaymath}
    F(x) =
    \begin{cases}
      0,5x, & 0 \leq x < 1 \\
      0,5   & 1 \leq x < 2 \\
      0,5x - 0,5, & 2 \leq x < 3.
    \end{cases}
  \end{displaymath}
  \enlargethispage{5mm}
  (Voir la \autoref{fig:simulation:mixte}.)

  \begin{figure}
    \centering
<<echo=FALSE,fig=TRUE, width=8, height=4>>=
par(mfrow = c(1, 2), mar = c(5, 4, 2, 2))
plot(NA, xlim = c(0, 3), ylim = c(0, 1),
     xlab = expression(x), ylab = expression(f[X](x)),
     xaxt = "n", yaxt = "n")
points(c(0, 1), rep(0.5, 2), type = "o", pch = c(19, NA))
points(c(1, 2), rep(0, 2), type = "o", pch = c(19, NA))
points(c(2, 3), rep(0.5, 2), type = "o", pch = c(19, NA))
axis(1, at = 0:3)
axis(2, at = 0:2/2)
plot(0:3, c(0, 0.5, 0.5, 1), type = "o", pch = 19,
     xlab = expression(x), ylab = expression(F[X](x)),
     xaxt = "n", yaxt = "n")
axis(1, at = 0:3)
axis(2, at = 0:2/2)
@
    \caption{Fonction de densité de probabilité (gauche) et fonction de
      répartition (droite) de l'\autoref{exemple:simulation:mixte}}
    \label{fig:simulation:mixte}
  \end{figure}

  Par conséquent, un algorithme pour simuler des nombres aléatoires de
  cette distribution est:
  \begin{enumerate}
  \item Obtenir un nombre $u$ d'une loi $U(0, 1)$.
  \item Poser
    \begin{displaymath}
      x =
      \begin{cases}
        2u,    & \text{si } 0 \leq u < 1 \\
        2,     & \text{si } u = 0,5 \\
        2u + 1 & \text{si } 0,5 < u < 1.
      \end{cases}
    \end{displaymath}
  \end{enumerate}
  \begin{gotoR}
    Une mise en {\oe}uvre en R de l'algorithme ci-dessus est présentée
    dans le code informatique de la
    \autoref{sec:simulation:code}.
  \end{gotoR}
  \qed
\end{exemple}

\begin{exemple}
  On veut simuler des observations d'une distribution binomiale de
  paramètres $n$ et $\theta$. On pourrait, pour chaque $x$ simulé,
  faire $n$ expériences de Bernoulli et compter le nombre de succès.
  Par la méthode de l'inverse pour la loi de Bernoulli, on a un succès
  si $u \leq \theta$. Par conséquent, un algorithme serait:
  \begin{enumerate}
  \item Simuler $n$ nombres uniformes indépendants $u_1, \dots, u_n$
    d'une loi $U(0, 1)$.
  \item Poser
    \begin{displaymath}
      x = \sum_{i = 1}^n I\{u_i \leq \theta\}.
    \end{displaymath}
  \end{enumerate}
  Cette technique requiert toutefois de simuler $n$ nombres uniformes
  pour chaque valeur de $x$.

  Il est plus efficace d'utiliser la méthode de l'inverse directement
  avec la distribution binomiale. Par exemple, si $n = 4$ et $\theta =
  0,5$, on a que
  \begin{align*}
    \Pr[X = x]
    &=
    \begin{cases}
      0,0625, & x = 0 \\
      0,25,   & x = 1 \\
      0,375,  & x = 2 \\
      0,25,   & x = 3 \\
      0,0625, & x = 4
    \end{cases} \\
    \intertext{et}
    \Pr[X \leq x]
    &=
    \begin{cases}
      0,      & x < 0 \\
      0,0625, & 0 \leq x < 1 \\
      0,3125, & 1 \leq x < 2 \\
      0,6875, & 2 \leq x < 3 \\
      0,9375, & 3 \leq x < 4 \\
      1,      & x \geq 4,
    \end{cases}
  \end{align*}
  d'où l'algorithme suivant:
  \begin{enumerate}
  \item Simuler un nombre $u$ d'une distribution $U(0, 1)$.
  \item Déterminer $x$ selon le tableau suivant:
    \begin{center}
      \begin{tabular}{lc}
        \toprule
        $u$ dans l'intervalle & Valeur de $x$ \\
        \midrule
        $[0, 0,0625)$         & $0$ \\
        $[0,0625, 0,3125)$    & $1$ \\
        $[0,3125, 0,6875)$    & $2$ \\
        $[0,6875, 0,9375)$    & $3$ \\
        $[0,9375, 1)$         & $4$ \\
        \bottomrule
      \end{tabular}
    \end{center}
  \end{enumerate}
  \qed
\end{exemple}

\begin{rem}
  La méthode de l'inverse pour les distributions discrètes à support
  fini est facile à mettre en {\oe}uvre dans Excel à l'aide de la
  fonction \texttt{RECHERCHEV()}.
\end{rem}


\section{Méthode acceptation-rejet}

Supposons qu'il est compliqué de simuler des réalisations de la
variable aléatoire $X$ avec fonction de densité de probabilité
$f_X(x)$. Si on peut trouver une variable aléatoire $Y$ avec fonction
de densité de probabilité $g_Y(x)$ pour laquelle la simulation est
simple (uniforme, triangle, exponentielle, etc.) et qu'il est possible
d'«envelopper» la densité $f$ par un multiple de $g$, c'est-à-dire que
\begin{displaymath}
  c g_Y(x) \geq f_X(x)
\end{displaymath}
pour tout $x$, alors on a l'algorithme d'acceptation-rejet suivant:
\begin{enumerate}
\item Générer une réalisation $y$ de la variable aléatoire $Y$ avec
  fonction de densité de probabilité $g_Y(\cdot)$.
\item Générer un nombre $u$ d'une $U(0, 1)$.
\item Si
  \begin{displaymath}
    u \leq \frac{f_X(y)}{c g_Y(y)},
  \end{displaymath}
  poser $x = y$. Sinon, retourner à l'étape 1.
\end{enumerate}

\begin{rem}
  Puisque, par définition, l'aire sous les densités $f$ et $g$ vaut $1$
  dans les deux cas on ne peut avoir $c g_Y(x) \geq f_X(x)$ pour tout
  $x$ que si $c > 1$.
\end{rem}

L'idée de la %
\capsule{http://youtu.be/acceptation-rejet}{méthode d'acceptation-rejet} %
consiste à accepter la «bonne proportion» des réalisations de $Y$
comme provenant de $X$. Dans l'illustration de la
\autoref{fig:simulation:acceptation-rejet}, la densité $f$ à support
fini est facilement enveloppée par un rectangle. Un nombre $y$ simulé
de cette distribution (à toutes fins pratiques une uniforme, ici) est
accepté comme provenant de $f$ dans une proportion correspondant au
ratio entre la valeur de $f_X(y)$ (les segments verts dans la figure)
et la valeur de $c g_Y(y)$ (les segments bleus). À l'inverse, le
nombre $y$ est rejeté selon le ratio de la longueur d'un segment rouge
sur celle d'un segment bleu. On voit donc que certaines valeurs $y$
seront rejetées plus souvent que d'autres en conformité avec la forme
de la densité.

\begin{figure}
  \centering
<<echo=FALSE, fig=TRUE>>=
plot(NA, xlim = c(0, 1), ylim = c(0, 2), xlab = "y", ylab = "f(y)")
m <- dbeta(2/3, 3, 2)
x <- c(0.22, 0.58, 0.83)
eps <- eps <- 40E-4
segments(x - eps, 0, x - eps, dbeta(x, 3, 2), col = "green3", lwd = 3)
segments(x - eps, dbeta(x, 3, 2), x - eps, m, col = "red3", lwd = 3)
segments(x + eps, 0, x + eps, m, col = "blue3", lwd = 3)
curve(dbeta(x, 3, 2), xlim = c(0, 1), add = TRUE, lwd = 2)
segments(0, 0, 0, m, col = "blue3")
segments(1, 0, 1, m, col = "blue3")
segments(0, m, 1, m, col = "blue3", lwd = 3)
text(0.1, m + 0.08, "c g(y)")
@
  \caption{Illustration de la méthode acceptation-rejet}
  \label{fig:simulation:acceptation-rejet}
\end{figure}

\begin{rems}
  \begin{enumerate}
  \item La principale difficulté avec cette méthode consiste à trouver
    la fonction enveloppante.
  \item Évidemment, plus $c g_Y(x)$ est près de $f_X(x)$, plus
    l'algorithme est performant puisque l'on rejette alors moins de
    valeurs.
  \item Il est aussi possible d'envelopper les densités à support
    infini; voir les exercices.
  \end{enumerate}
\end{rems}

\begin{exemple}
  \label{exemple:simulation:beta:1}
  Soit $X \sim \text{Bêta}(3, 2)$. On a
  \begin{align*}
    f_X(x)
    &= \frac{\Gamma(5)}{\Gamma(3) \Gamma(2)}\,
    x^{3 - 1} (1 - x)^{2 - 1} \\
    &= 12 x^2 (1 - x), \quad 0 < x < 1.
  \end{align*}
  C'est la densité représentée à la
  \autoref{fig:simulation:acceptation-rejet}. On l'inscrit facilement
  dans un rectangle. Le mode de la densité se trouvant en $x = 2/3$,
  la hauteur du rectangle est $f(2/3) = 48/27 = 16/9$. Par conséquent,
  \begin{displaymath}
    c g_Y(x) = \frac{16}{9}, \quad 0 < x < 1.
  \end{displaymath}
  On déduit que $c = 16/9$ et que la densité $g$ est une uniforme sur
  $(0 , 1)$. On a donc l'algorithme suivant:
  \begin{enumerate}
  \item Simuler deux nombres $u_1$ et $u_2$ d'une $U(0, 1)$.
  \item Poser $y = u_1$.
  \item Si
    \begin{displaymath}
      u_2 \leq \frac{f_X(y)}{16/9},
    \end{displaymath}
    alors poser $x = y$. Sinon, retourner à l'étape 1.
  \end{enumerate}

  L'aire du rectangle étant de $16/9 \approx 1,78$, on peut s'attendre
  à rejeter environ $78~\%$ des nombres $u_1$ simulés à l'étape~1 de
  l'algorithme ci-dessus. Si l'enveloppe
  était plus «serrée» autour de la densité, l'efficacité de
  l'algorithme en serait augmentée.
  \qed
\end{exemple}

\begin{exemple}
  \label{exemple:simulation:beta:2}
  On reprend l'\autoref{exemple:simulation:beta:1} en tentant
  d'améliorer l'efficacité de l'algorithme. Il s'avère que l'on peut
  inscrire la densité de la loi Bêta$(3, 2)$ dans un triangle aux
  caractéristiques suivantes (voir la
  \autoref{fig:simulation:beta-triangle}):
  \begin{figure}
    \centering
<<echo=FALSE, fig=TRUE>>=
curve(dbeta(x, 3, 2), xlim = c(0, 1), ylim = c(0, 2.5), lwd = 2)
lines(c(0, 0.8, 1), c(0, 2.4, 0), lwd = 2, col = "blue3")
segments(0.5, 0, 0.5, 1.5, lty = 2)
segments(0.8, 0, 0.8, 2.4, lty = 2)
axis(side = 1, at = 0.5)
@
    \caption{Fonction de densité de probabilité d'une loi Bêta$(3, 2)$
      enveloppée d'un triangle}
    \label{fig:simulation:beta-triangle}
  \end{figure}
  \begin{enumerate}
  \item l'arête gauche passe par $(0, 0)$, donc est de la forme $y =
    mx$. Cette droite étant tangente à $f(x)$, la pente $m$ est telle
    que l'équation $mx = 12 x^2 (1 - x)$ a une seule racine autre que
    $0$, d'où $y = 3 x$;
  \item l'arête droite passe par $(1, 0)$, donc est de la forme $y =
    mx + b$ avec $m + b = 0$. Comme la pente de cette droite est égale
    à la pente de $f(x)$ en $x = 1$, on trouve que $y = 12 - 12 x$.
  \end{enumerate}
  Ainsi,
  \begin{displaymath}
    c g_Y(x) =
    \begin{cases}
      3x,       & 0 < x < 0,8 \\
      12 - 12 x, & 0,8 < x < 1.
    \end{cases}
  \end{displaymath}
  Or, l'aire du triangle est
  \begin{displaymath}
    \frac{(1) c g_Y(0,8)}{2} = \frac{(1)(2,4)}{2} = 1,2,
  \end{displaymath}
  d'où $c = 1,2$. Par conséquent,
  \begin{align*}
    g_Y(x)
    &=
    \begin{cases}
      2,5 x,     & 0 < x < 0,8 \\
      10 - 10 x, & 0,8 < x < 1.
    \end{cases}
  \end{align*}
  Pour simuler des observations de cette densité par la méthode de
  l'inverse, on calcule la fonction de répartition correspondante
  \begin{align*}
    G_Y(x)
    &=
    \begin{cases}
      1,25 x^2,          & 0 < x < 0,8 \\
      -5 x^2 + 10 x - 4, & 0,8 < x < 1,
    \end{cases} \\
    \intertext{d'où}
    G_Y^{-1}(y)
    &=
    \begin{cases}
      \sqrt{0,8 y},           & 0 < y < 0,8 \\
      1 - \sqrt{0,2 - 0,2 y}, & 0,8 < y < 1.
    \end{cases}
  \end{align*}
  Au final, on a l'algorithme suivant:
  \begin{enumerate}
  \item Simuler deux nombres $u_1$ et $u_2$ d'une $U(0, 1)$.
  \item Poser $y = G_Y^{-1}(u_1)$.
  \item Si
    \begin{displaymath}
      u_2 \leq \frac{f_X(y)}{1,2 g_Y(y)} \Leftrightarrow
      1,2 g_Y(y) u_2 \leq f_X(y),
    \end{displaymath}
    alors poser $x = y$. Sinon, retourner à l'étape 1.
  \end{enumerate}

  L'aire du triangle étant de $1,2$, on peut maintenant s'attendre à
  ne rejeter que $20~\%$ des nombres simulés, une amélioration
  importante par rapport à l'\autoref{exemple:simulation:beta:1}. %
  \qed
\end{exemple}

\SweaveOpts{height=3, width=4}
  \begin{figure}
    \centering
<<echo=FALSE, fig=TRUE, results=hide>>=
## Graphique.
set.seed(314516)

x <- runif(200, -1, 1)
y <- runif(200, -1, 1)

par(mar=c(4,5,0.5,4))

plot(x[(x^2 + y^2) < 1], y[(x^2 + y^2) < 1], xlab="x", ylab="y", pch=16, col="gray49",
        xlim=c(-1, 1), ylim=c(-1, 1))
points(x[(x^2 + y^2) >= 1], y[(x^2 + y^2) >= 1], xlab="x", ylab="y", pch=1)

r <- 1
t <- seq(0, 2 * pi, length = 1000)
lines(x = r * cos(t), y = r * sin(t), lwd=2)
@
    \caption{Acceptation-rejet sur un disque}
    \label{fig:simulation:disque}
  \end{figure}

\begin{prob-astuce}
  La méthode acceptation-rejet présentée ci-haut peut
  être adaptée au problème présenté en ouverture de
  chapitre. En effet, afin de générer des points
  distribués uniformément sur un disque, il s'agit de
  simuler des points uniformément sur un carré et de
  rejeter ceux qui ne se trouvent pas à l'intérieur du
  disque. Dans la \autoref{fig:simulation:disque}, 
  on accepterait les points gris et on rejeterait les
  points vides.
\end{prob-astuce}

\section{Fonctions de simulation de variables aléatoires dans Excel,
  VBA et \textsf{R}}
\label{sec:simulation:excel_et_al}

Il est important de savoir simuler des valeurs d'une variable
aléatoire quelconque à partir de la méthode de l'inverse ou d'un autre
algorithme, surtout si la distribution de la variable aléatoire est
peu usitée. Néanmoins, les différents outils statistiques fournissent
en général la majorité des fonctions de simulation de variables
aléatoires dont on peut avoir besoin pour un usage quotidien.


\subsection{Excel et VBA}

Tel que mentionné à la section 3.1, il faut généralement utiliser la
méthode de l'inverse pour simuler des observations de lois de
probabilité dans Excel. Cette procédure est facilitée par le fait
qu'il existe des fonctions Excel pour calculer la fonction de
répartition inverse (ou fonction de quantile) des lois les plus
courantes.

Ainsi, on trouvera dans Excel la fonction de densité de probabilité
(lois continues) ou la fonction de masse de probabilité (lois
discrètes) ou la fonction de répartition et, dans certains cas
seulement, la fonction de quantile des lois de probabilité présentées
au \autoref{tab:excel}. Les noms anglais des fonctions ont été
modifiés pour être standardisés dans Excel~2010. On remarquera que les
traducteurs français ont omis de faire de même.

\begin{table}[t]
  \centering
  \begin{tabularx}{\linewidth}{lp{17ex}X}
    \toprule
    Loi de probabilité &
    Fonctions Excel \newline (nom anglais) &
    Fonctions Excel \newline (nom français) \\
    \midrule
    Bêta &
    \code{BETA.DIST} \newline \code{BETA.INV} &
    \code{LOI.BETA.N} \newline \code{BETA.INVERSE.N} \\
    Binomiale &
    \code{BINOM.DIST} \newline \code{BINOM.INV} &
    \code{LOI.BINOMALE.N} \newline \code{LOI.BINOMIALE.INVERSE} \\
    Binomiale négative &
    \code{NEGBINOM.DIST} &
    \code{LOI.BINOMIALE.NEG.N} \\
    Exponentielle &
    \code{EXPON.DIST} &
    \code{LOI.EXPONENTIELLE.N} \\
    \emph{F} (Fisher) &
    \code{F.DIST} \newline \code{F.INV} &
    \code{LOI.F.N} \newline \code{INVERSE.LOI.F.N} \\
    Gamma &
    \code{GAMMA.DIST} \newline \code{GAMMA.INV} &
    \code{LOI.GAMMA.N} \newline \code{LOI.GAMMA.INVERSE.N} \\
    Hypergéométrique &
    \code{HYPGEOM.DIST} &
    \code{LOI.HYPERGEOMETRIQUE.N} \\
    Khi carré &
    \code{CHISQ.DIST} \newline \code{CHISQ.INV} &
    \code{LOI.KHIDEUX} \newline \code{LOI.KHIDEUX.INVERSE} \\
    Log-normale &
    \code{LOGNORM.DIST} \newline \code{LOGNORM.INV} &
    \code{LOI.LOGNORMALE.N} \newline \code{LOI.LOGNORMALE.INVERSE.N} \\
    Normale &
    \code{NORM.DIST} \newline
    \code{NORM.INV} \newline
    \code{NORM.S.DIST} \newline
    \code{NORM.S.INV} &
    \code{LOI.NORMALE.N} \newline
    \code{LOI.NORMALE.INVERSE.N} \newline
    \code{LOI.NORMALE.STANDARD.N} \newline
    \code{LOI.NORMALE.STANDARD.INVERSE.N} \\
    Poisson &
    \code{POISSON.DIST} &
    \code{LOI.POISSON.N} \\
    \emph{t} (Student) &
    \code{T.DIST} \newline \code{T.INV} &
    \code{LOI.STUDENT.N} \newline \code{LOI.STUDENT.INVERSE.N} \\
    Weibull &
    \code{WEIBULL.DIST} &
    \code{LOI.WEIBULL.N} \\
    \bottomrule
  \end{tabularx}
  \caption{Liste des fonctions relatives à des lois de probabilité
    depuis Excel 2010.}
  \label{tab:excel}
\end{table}

Aucune fonction statistique n'existe dans VBA. On fera donc appel aux
fonctions de Excel en préfixant les noms de fonctions \emph{anglais}
du \autoref{tab:excel} de la propriété \code{WorksheetFunction}.
En utilisant une structure
\begin{verbatim}
With WorksheetFunction
    ...
End With
\end{verbatim}
dans une routine VBA, il est également possible accéder directement
aux fonctions Excel en les préfixant seulement d'un point.


\subsection{R}

\input{rng-lois}

\begin{gotoR}
  Le code informatique R de la \autoref{sec:simulation:code}
  contient des exemples plus détaillés d'utilisation des fonctions
  mentionnées ci-dessus.
\end{gotoR}



\section{Autres techniques de simulation}
\label{sec:simulation:autres}

Il existe plusieurs autres algorithmes de simulation de loi non
uniformes, certains beaucoup plus élaborés que d'autres. Nous
n'irons pas plus loin dans ce sujet dans ce cours, sinon pour
mentionner deux autres techniques simples qui sont souvent employées
en actuariat:
\begin{enumerate}
\item les mélanges de distributions continus et discrets;
\item la convolution de variables aléatoires.
\end{enumerate}

\begin{gotoR}
  Ces techniques sont présentées et illustrées à même le code
  informatique R de la \autoref{sec:simulation:code}.
\end{gotoR}

En terminant, mentionnons que l'\autoref{planification} propose
quelques trucs pour bien planifier une étude de simulation en R.

\begin{prob-solution}
  La première étape consiste à créer une fonction qui
  génère \code{n} points distribués uniformément sur
  un cercle :
  
<<echo=TRUE>>=
sim.cercle1 <- function(n)
{
    ### On crée le contenant vide
    X <- matrix(NA, n, 2)
    
    ### puis on le remplit.
    i <- 1
    repeat
    {
        ### On soumet à l'algorithme acceptation-
        ### rejet 2 coordonnées entre -1 et 1
        x <- runif(2, -1, 1)
        
        ### Si les coordonnées sont dans
        ### le cercle...
        if (sum(x^2) < 1)
        {
            ### ... on ajoute la paire
            ### à la matrice 'X'.
            X[i, ] <- x
            
            ### On cesse lorsque 'X'
            ### contient 'n' rangées.
            if (n < (i <- i + 1))
                break
        }
    }
    X
}
@

  Ensuite, on utilise la fonction pour calculer par
  simulation la probabilité recherchée, comme à
  l'exemple du chapitre précédent :

<<<echo=TRUE>>=
set.seed(17)
mean(replicate(100000,
        3 == length(chull(sim.cercle1(4))) ))
@
    
  Remarque : Il est à noter qu'une autre solution
  permet de générer des points uniformément dans
  un cercle sans procéder à la méthode
  acceptation-rejet. Cette méthode repose sur la
  simulation de coordonnées polaires, puis de leur
  transformation en coordonnées cartésiennes :
  
<<echo=TRUE>>=
sim.cercle2 <- function(n)
{
    r <- runif(n)
    angle <- runif(n, 0, 2 * pi)
    sqrt(r) * cbind(cos(angle), sin(angle))
}

set.seed(17)
mean(replicate(100000,
               3 == length(chull(sim.cercle2(4))) ))
@

  Pour plus de détails sur cette méthode, vous référer
  à l'\autoref{ex:simulation:cercle}.
\end{prob-solution}

\section{Code informatique}
\label{sec:simulation:code}

\lstinputlisting[firstline=3]{simulation.R}

\vfill

\input{exercices-simulation}

%%% Local Variables:
%%% TeX-master: "methodes_numeriques-partie_2"
%%% coding: utf-8
%%% End:
