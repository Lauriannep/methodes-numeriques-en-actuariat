\chapter{Intégration numérique}
\label{chap:integration}

\begin{objectifs}
\item Être en mesure de calculer la valeur approximative d’une
  intégrale définie à l’aide des méthodes du point milieu, du trapèze,
  de Simpson et de Simpson 3/8.
\item Avoir une connaissance générale de ce qu'est un polynôme
  d'interpolation de Lagrange.
\item Être en mesure de développer les formules d'approximation
  composées de chacune des méthodes d'intégration numériques
  présentées dans le chapitre.
\end{objectifs}

<<echo=FALSE>>=
options(width = 60)
@

Il n'est pas rare de devoir calculer l'intégrale d'une fonction qui
n'admet pas de primitive sous forme explicite ou dont la primitive est
très difficile à calculer. Dans de tels cas, l'intégration numérique
permet d'obtenir une approximation --- parfois excellente --- de
l'intégrale cherchée.


\section{Mise en contexte}
\label{sec:integration:contexte}

Supposons que l'on cherche à calculer $\int_a^b f(x)\, dx$. Toutes les
méthodes d'intégration numérique reposent, en premier lieu, sur le
découpage du domaine $(a, b)$ en $n$ intervalles. Cela permet
d'évaluer l'intégrale comme une somme d'intégrales sur chacun de ces
intervalles:
\begin{equation*}
  \int_a^b f(x)\, dx = \sum_{j=0}^{n-1} \int_{x_j}^{x_{j+1}} f(x)\, dx.
\end{equation*}
Les diverses méthodes d'intégration numérique diffèrent par la suite
essentiellement par l'approximation de la fonction $f(x)$ sur
l'intervalle $(x_j, x_{j+1})$ utilisée afin de rendre l'intégrale
$\int_{x_j}^{x_{j+1}} f(x)\, dx$ simple à calculer.

La figure~\ref{fig:integration:methodes} illustre les procédures
d'approximation de quatre méthodes courantes d'intégration numérique.

<<echo=FALSE>>=
### Définition de la fonction.
f <- function(x)
{
    x <- (x + 0.2)/1.5
    (dgamma(x, 1.2, 0.5) + dgamma(x, 5, 1))/2 - 0.12
}
@

\SweaveOpts{height=4, width=4}
\begin{figure}[tp]
  \begin{minipage}[t]{0.48\linewidth}
    \centering
<<echo=FALSE, fig=TRUE, results=hide>>=
### Graphique avec point milieu.
par(mar = c(4, 3, 2, 2))
curve(f, xlim = c(0, 6), lwd = 3,
      axes = FALSE, xlab = "", ylab = "")
rect(xleft = 0:5, ybottom = 0, xright = 1:6, ytop = f(1:6 - 0.5),
     density = 5, col = "blue", border = "blue")
axis(1, at = 0:6,
     labels = parse(text = c("a", paste("x[", 1:5*2, "]", sep = ""), "b")))
axis(2)
box()
@
    \subcaption{point milieu \label{fig:integration:methodes:pointmilieu}}
  \end{minipage}
  \begin{minipage}[t]{0.48\linewidth}
    \centering
<<echo = FALSE, fig=TRUE, results=hide>>=
### Graphique avec trapèze
par(mar = c(4, 3, 2, 2))
curve(f, xlim = c(0, 6), lwd = 3,
      axes = FALSE, xlab = "", ylab = "")
x <- 0:6
xx <- c(0, x, 6)
yy <- c(0, f(x), 0)
polygon(xx, yy, density = 5, col = "blue", border = "blue")
segments(x, 0, x, f(x), col = "blue")
axis(1, at = 0:6,
     labels = parse(text = c("a", paste("x[", 1:5, "]", sep = ""), "b")))
axis(2)
box()
@
    \subcaption{trapèze \label{fig:integration:methodes:trapeze}}
  \end{minipage}
  \newline
  \begin{minipage}[t]{0.48\linewidth}
    \centering
<<echo=FALSE, fig=TRUE, results=hide>>=
### Graphique avec Simpson.
## Calcul des polynômes d'interpolation par intervalle.
library(polynom)
x0 <- matrix(c(0:2, 2:4, 4:6, 6:8, 8:10, 10:12)/2, nrow = 3)
y0 <- f(x0)
P2.1 <- poly.calc(x0[,1], y0[,1])
P2.2 <- poly.calc(x0[,2], y0[,2])
P2.3 <- poly.calc(x0[,3], y0[,3])
P2.4 <- poly.calc(x0[,4], y0[,4])
P2.5 <- poly.calc(x0[,5], y0[,5])
P2.6 <- poly.calc(x0[,6], y0[,6])

## Polynôme d'interpolation global.
h <- function(x)
{
    f <- function(x) eval(parse(text = paste("predict(P2.", min(floor(x+1), 6), ", x)", sep = "")))
    sapply(x, f)
}

## Graphique.
xx <- c(0, seq(0, 6, by = 0.01), 6)
yy <- c(0, h(seq(0, 6, by = 0.01)), 0)
par(mar = c(4, 3, 2, 2))
curve(f, xlim = c(0, 6), lwd = 3,
      axes = FALSE, xlab = "", ylab = "")
polygon(xx, yy, density = 5, col = "blue", border = "blue")
segments(x, 0, x, f(x), col = "blue")
axis(1, at = 0:6,
     labels = parse(text = c("a", paste("x[", 1:5, "]", sep = ""), "b")))
axis(2)
box()
@
    \subcaption{Simpson \label{fig:integration:methodes:simpson}}
  \end{minipage}
  \begin{minipage}[t]{0.48\linewidth}
    \centering
<<echo=FALSE, fig=TRUE, results=hide>>=
### Graphique avec Simpson 3/8.
## Calcul des polynômes d'interpolation par intervalle.
x0 <- matrix(c(0:3, 3:6, 6:9, 9:12, 12:15, 15:18)/3, nrow = 4)
y0 <- f(x0)
P3.1 <- poly.calc(x0[,1], y0[,1])
P3.2 <- poly.calc(x0[,2], y0[,2])
P3.3 <- poly.calc(x0[,3], y0[,3])
P3.4 <- poly.calc(x0[,4], y0[,4])
P3.5 <- poly.calc(x0[,5], y0[,5])
P3.6 <- poly.calc(x0[,6], y0[,6])

## Polynôme d'interpolation global.
h <- function(x)
{
    f <- function(x) eval(parse(text = paste("predict(P3.", min(floor(x+1), 6), ", x)", sep = "")))
    sapply(x, f)
}

## Graphique.
xx <- c(0, seq(0, 6, by = 0.01), 6)
yy <- c(0, h(seq(0, 6, by = 0.01)), 0)
par(mar = c(4, 3, 2, 2))
curve(f, xlim = c(0, 6), lwd = 3,
      axes = FALSE, xlab = "", ylab = "")
polygon(xx, yy, density = 5, col = "blue", border = "blue")
segments(x, 0, x, f(x), col = "blue")
axis(1, at = 0:6,
     labels = parse(text = c("a", paste("x[", 1:5, "]", sep = ""), "b")))
axis(2)
box()
@
    \subcaption{Simpson 3/8 \label{fig:integration:methodes:simpson38}}
  \end{minipage}
  \caption{Comparaison de quatre méthodes d'intégration numérique}
  \label{fig:integration:methodes}
\end{figure}

Les quatre formules d'intégration numérique présentées ci-dessous
découlent de la procédure suivante: le domaine d'intégration $(a, b)$
est découpé en $n$ intervalles de longueur égale. Chacun de ces
intervalles est à son tour divisé en $m$ sous-intervalles de longueur
égale, pour un total de $nm$ points. On a alors
\begin{align*}
  \int_a^b f(x)\, dx
  &= \int_{x_0}^{x_m} f(x)\, dx
  + \int_{x_m}^{x_{2m}} f(x)\, dx + \dotsi
  + \int_{x_{(n-1)m}}^{x_{nm}} f(x)\, dx \\
  &= \sum_{j=0}^{n - 1} \int_{x_{jm}}^{x_{(j+1)m}} f(x)\, dx,
\end{align*}
où $x_0 = a$ et $x_{nm} = b$. L'approximation numérique se trouve dans
l'évaluation de l'intégrale du côté droit de la dernière équation.

Afin de ne pas alourdir inutilement la notation, les formules
d'approximation de l'intégrale
\begin{equation*}
  \int_{x_{jm}}^{x_{(j+1)m}} f(x)\, dx
\end{equation*}
seront ci-dessous présentées pour le cas $j = 0$ seulement.


\section{Méthode du point milieu}
\label{sec:integration:pointmilieu}

La méthode du point milieu est la plus simple et la plus intuitive.
Les intervalles sont divisés en $m = 2$ parties et la valeur de la
fonction $f$ sur l'intervalle $(x_0, x_2)$ est estimée par $f(x_1)$
(figure~\ref{fig:integration:grosplan:pointmilieu}). Ainsi, on a
l'approximation
\begin{displaymath}
  \int_{x_0}^{x_2} f(x)\, dx \approx 2 h f(x_1),
\end{displaymath}
où $h = x_2 - x_1 = x_1 - x_0$.

La formule composée pour l'approximation par la méthode du point
milieu de $\int_a^b f(x)\, dx$ avec $n$ intervalles est
\begin{displaymath}
  \int_a^b f(x)\, dx \approx 2 h \sum_{j=0}^{n - 1} f(x_{2j + 1})
\end{displaymath}
où $h = (b - a)/(2 n)$ et $x_j = a + jh$.


\section{Polynômes d'interpolation de Lagrange}
\label{sec:integration:Lagrange}



\section{Méthode du trapèze}
\label{sec:integration:trapeze}

Les trois prochaines méthodes d'intégration numérique sont basées sur
l'approximation de la fonction $f$ sur un intervalle par un polynôme
d'interpolation de Lagrange de degré $m$.

La méthode du trapèze utilise un polynôme du premier degré ($m = 1$)
pour faire l'approximation de la valeur de $f(x)$ sur l'intervalle
$(x_0, x_1)$, ce qui est équivalent à une simple interpolation
linéaire (figure~\ref{fig:integration:grosplan:trapeze}). On a donc
\begin{equation*}
  \int_{x_0}^{x_1} f(x)\, dx \approx  \frac{h}{2}[f(x_0) + f(x_1)],
\end{equation*}
où $h = x_1 - x_0$. Contrairement à ce que peut évoquer la figure
\ref{fig:integration:methodes}, cette méthode est généralement plus
précise que la méthode du point milieu.

La formule composée pour l'approximation de $\int_a^b f(x)\, dx$ par
la méthode du trapèze avec $n$ intervalles est
\begin{equation*}
  \int_a^b f(x)\, dx \approx \frac{h}{2}
  \left[
    f(a) + f(b) + 2 \sum_{j = 1}^{n - 1} f(x_j)
  \right],
\end{equation*}
où $h = (b - a)/n$ et $x_j = a + jh$.

\begin{figure}[t]
  \begin{minipage}[t]{0.48\linewidth}
    \centering
<<echo=FALSE, fig=TRUE, results=hide>>=
### Gros plan sur point milieu.
g <- function(x) f(3.5 * x + 1.5)
par(mar = c(3, 0, 0, 0))
curve(g, xlim = c(0, 1), lwd = 3, ylim = c(0.020, 0.035),
      axes = FALSE, xlab = "", ylab = "")
lines(c(0, 1), rep(g(0.5), 2), col = "blue")
points(0.5, g(0.5), pch = 16, col = "blue", cex = 1.5)
axis(1, at = c(0, 0.5, 1),
     labels = expression(x[0], x[1], x[2]))
@
  \subcaption{point milieu \label{fig:integration:grosplan:pointmilieu}}
  \end{minipage}
  \begin{minipage}[t]{0.48\linewidth}
    \centering
<<echo = FALSE, fig=TRUE, results=hide>>=
### Gros plan sur trapèze.
par(mar = c(3, 0, 0, 0))
curve(g, xlim = c(0, 1), lwd = 3, ylim = c(0.020, 0.035),
      axes = FALSE, xlab = "", ylab = "")
lines(0:1, g(0:1), col = "blue")
points(0:1, g(0:1), pch = 16, col = "blue", cex = 1.5)
axis(1, at = c(0, 1), labels = parse(text = c("x[0]", "x[1]")))
@
  \subcaption{trapèze \label{fig:integration:grosplan:trapeze}}
  \end{minipage}
  \newline
  \begin{minipage}[t]{0.48\linewidth}
    \centering
<<echo=FALSE, fig=TRUE, results=hide>>=
### Gros plan sur Simpson.
x0 <- seq(0, 1, by = 0.5)
y0 <- g(x0)
P2 <- poly.calc(x0, y0)
h <- function(x) predict(P2, x)
par(mar = c(3, 0, 0, 0))
curve(g, xlim = c(0, 1), lwd = 3, ylim = c(0.020, 0.035),
      axes = FALSE, xlab = "", ylab = "")
curve(h, xlim = c(0, 1), add = TRUE, col = "blue")
points(x0, y0, pch = 16, col = "blue", cex = 1.5)
axis(1, at = c(0, 0.5, 1), labels = parse(text = c("x[0]", "x[1]", "x[2]")))
@
  \subcaption{Simpson \label{fig:integration:grosplan:simpson}}
  \end{minipage}
  \begin{minipage}[t]{0.48\linewidth}
    \centering
<<echo=FALSE, fig=TRUE, results=hide>>=
### Gros plan sur Simpson 3/8.
x0 <- seq(0, 1, by = 1/3)
y0 <- g(x0)
P3 <- poly.calc(x0, y0)
h <- function(x) predict(P3, x)
par(mar = c(3, 0, 0, 0))
curve(g, xlim = c(0, 1), lwd = 3, ylim = c(0.020, 0.035),
      axes = FALSE, xlab = "", ylab = "")
curve(h, xlim = c(0, 1), add = TRUE, col = "blue")
points(x0, y0, pch = 16, col = "blue", cex = 1.5)
axis(1, at = c(0, 1/3, 2/3, 1),
     labels = parse(text = c("x[0]", "x[1]", "x[2]", "x[3]")))
@
  \subcaption{Simpson 3/8 \label{fig:integration:grosplan:simpson38}}
  \end{minipage}
  \caption{Approximation de $f(x)$ sur un intervalle}
  \label{fig:integration:grosplan}
\end{figure}


\section{Méthode de Simpson}
\label{sec:integration:simpson}

La méthode d'approximation de Simpson est la plus usuelle des méthodes
d'intégration numérique, encore que pas nécessairement la plus
précise. La fonction $f(x)$ est remplacée, sur l'intervalle $(x_0,
x_2)$, par un polynôme d'interpolation de Lagrange du second degré
(figure~\ref{fig:integration:grosplan:simpson}). On a donc $m = 2$ et
on peut démontrer que
\begin{equation*}
  \int_{x_0}^{x_2} f(x)\, dx \approx \frac{h}{3}[f(x_0) + 4f(x_1) + f(x_2)],
\end{equation*}
où $h = x_2 - x_1 = x_1 - x_0$. Cette méthode d'approximation
numérique s'avère exacte pour les fonctions polynomiales de degré
trois ou moins.

La formule composée pour l'approximation par la méthode de Simpson de
$\int_a^b f(x)\, dx$ avec $n$ intervalles est
\begin{displaymath}
  \int_a^b f(x)\, dx \approx \frac{h}{3}
  \left[
    f(a) +  2 \sum_{j = 1}^{n - 1} f(x_{2j}) +
    4 \sum_{j = 1}^n f(x_{2j-1}) + f(b)
  \right],
\end{displaymath}
où $h = (b - a)/(2n)$ et $x_j = a + jh$.


\section{Méthode de Simpson 3/8}
\label{sec:integration:simpson38}

La méthode de Simpson 3/8 constitue une extension de la méthode de
Simpson où la fonction $f$ est remplacée par un polynôme
d'interpolation de degré $m = 3$
(figure~\ref{fig:integration:grosplan:simpson38}). On peut alors
démontrer que
\begin{displaymath}
  \int_{x_0}^{x_3} f(x)\, dx \approx \frac{3h}{8}[f(x_0) + 3f(x_1) +
  3f(x_2) + f(x_3)],
\end{displaymath}
où $h = x_3 - x_2 = x_2 - x_1 = x_1 - x_0$. La dérivation de la
formule composée d'approximation de $\int_a^b f(x)\, dx$ avec $n$
intervalles est laissée en exercice.

Consulter \cite{Burden:numerical:1988} et les deux articles de
Mathworld cités en références pour de plus amples détails sur ces
méthodes d'intégration numérique et les polynômes d'interpolation de
Lagrange.


\section{Problèmes}

\begin{exercice}
  Écrire en des fonctions \textsf{R} nommées \texttt{pointmilieu},
  \texttt{trapeze}, \texttt{simpson} et \texttt{simpson38} pour
  intégrer une fonction $f$ entre deux bornes finies $a$ et $b$ par
  les méthodes d'intégration numérique correspondantes. En utilisant
  judicieusement la fonction \texttt{seq}, ces quatre fonctions
  peuvent --- et \emph{doivent} --- ne compter aucune boucle. Leurs
  arguments seront:
  \begin{itemize}
  \item \texttt{FUN}, la fonction à intégrer;
  \item \texttt{lower}, la borne d'intégration inférieure $a$;
  \item \texttt{upper}, la borne d'intégration supérieure $b$;
  \item \texttt{subdivisions}, le nombre $n$ d'intervalles à utiliser.
  \end{itemize}
  \begin{sol}
    Voir les figures \ref{fig:pointmilieu}--\ref{fig:simpson38} pour
    le code des fonctions.
    \begin{figure}[tp]
      \centering
      \begin{framed}
\begin{verbatim}
pointmilieu <- function(FUN, lower, upper,
                        subdivisions = 1000)
{
    if (upper <= lower)
        stop("upper should be larger than lower")
    if (identical(all.equal(lower, upper), TRUE))
        return(0)

    h <- (upper - lower) / (2 * subdivisions)

    x <- seq(from = lower + h, to = upper - h,
             by = 2 * h)

    2 * h * sum(FUN(x))
}
\end{verbatim}
      \end{framed}
      \caption{Fonction pour la méthode du point milieu}
      \label{fig:pointmilieu}
    \end{figure}

    \begin{figure}[tp]
      \centering
      \begin{framed}
\begin{verbatim}
trapeze <- function(FUN, lower, upper,
                    subdivisions = 1000)
{
    if (upper <= lower)
        stop("upper should be larger than lower")
    if (identical(all.equal(lower, upper), TRUE))
        return(0)

    h <- (upper - lower) / subdivisions

    x <- seq(from = lower + h, to = upper - h, by = h)

    h * sum(c(FUN(c(lower, upper)), 2 * FUN(x)))/2
}
\end{verbatim}
      \end{framed}
      \caption{Fonction pour la méthode du trapèze}
    \end{figure}

    \begin{figure}[tp]
      \centering
      \begin{framed}
\begin{verbatim}
simpson <- function(FUN, lower, upper,
                    subdivisions = 1000)
{
    if (upper <= lower)
        stop("upper should be larger than lower")
    if (identical(all.equal(lower, upper), TRUE))
        return(0)

    h <- (upper - lower) / (2 * subdivisions)

    x1 <- seq(from = lower + h, to = upper - h,
              by = 2 * h)
    x2 <- x1[-length(x1)] + h

    h * sum(c(FUN(c(lower, upper)),
              4 * FUN(x1),
              2 * FUN(x2)))/3
}
\end{verbatim}
      \end{framed}
      \caption{Fonction pour la méthode de Simpson}
    \end{figure}

    \begin{figure}[tp]
      \centering
      \begin{framed}
\begin{verbatim}
simpson38 <- function(FUN, lower, upper,
                      subdivisions = 1000)
{
    if (upper <= lower)
        stop("upper should be larger than lower")
    if (identical(all.equal(lower, upper), TRUE))
        return(0)

    h <- (upper - lower) / (3 * subdivisions)

    x1 <- seq(from = lower + h, to = upper - h,
              by = 3 * h)
    x2 <- x1 + h
    x3 <- x2[-length(x2)] + h

    3 * h * sum(c(FUN(c(lower, upper)),
                3 * FUN(c(x1, x2)),
                2 * FUN(x3)))/8
}
\end{verbatim}
      \end{framed}
      \caption{Fonction pour la méthode de Simpson 3/8}
      \label{fig:simpson38}
    \end{figure}

<<echo=FALSE>>=
pointmilieu <- function(FUN, lower, upper, subdivisions = 1000)
{
    if (upper <= lower)
        stop("upper should be larger than lower")
    if (identical(all.equal(lower, upper), TRUE))
        return(0)

    h <- (upper - lower) / (2 * subdivisions)

    x <- seq(from = lower + h, to = upper - h, by = 2 * h)

    2 * h * sum(FUN(x))
}

trapeze <- function(FUN, lower, upper, subdivisions = 1000)
{
    if (upper <= lower)
        stop("upper should be larger than lower")
    if (identical(all.equal(lower, upper), TRUE))
        return(0)

    h <- (upper - lower) / subdivisions

    x <- seq(from = lower + h, to = upper - h, by = h)

    h * sum(c(FUN(c(lower, upper)), 2 * FUN(x)))/2
}

simpson <- function(FUN, lower, upper, subdivisions = 1000)
{
    if (upper <= lower)
        stop("upper should be larger than lower")
    if (identical(all.equal(lower, upper), TRUE))
        return(0)

    h <- (upper - lower) / (2 * subdivisions)

    x1 <- seq(from = lower + h, to = upper - h, by = 2 * h)
    x2 <- x1[-length(x1)] + h

    h * sum(c(FUN(c(lower, upper)), 4 * FUN(x1), 2 * FUN(x2)))/3
}

simpson38 <- function(FUN, lower, upper, subdivisions = 1000)
{
    if (upper <= lower)
        stop("upper should be larger than lower")
    if (identical(all.equal(lower, upper), TRUE))
        return(0)

    h <- (upper - lower) / (3 * subdivisions)

    x1 <- seq(from = lower + h, to = upper - h, by = 3 * h)
    x2 <- x1 + h
    x3 <- x2[-length(x2)] + h

    3 * h * sum(c(FUN(c(lower, upper)), 3 * FUN(c(x1, x2)), 2 * FUN(x3)))/8
}
@
  \end{sol}
\end{exercice}

\begin{exercice}
  La fonction de densité d'une loi normale centrée réduite est
  \begin{displaymath}
    f(x) = \frac{1}{\sqrt{2\pi}}\, e^{-x^2/2}.
  \end{displaymath}
  Calculer la valeur de $F(1) - F(0) = \int_0^1 f(x)\, dx$ à l'aide
  des méthodes suivantes.
  \begin{enumerate}
  \item La méthode du point milieu.
  \item La méthode du trapèze.
  \item La méthode de Simpson.
  \item La méthode de Simpson 3/8.
  \item L'intégration Monte-Carlo.
  \item La fonction \textsf{R} \texttt{integrate}.
  \item La fonction \textsf{R} \texttt{pnorm}.
  \end{enumerate}
  Commenter brièvement les résultats, entre autres l'effet du nombre
  d'intervalles sur ceux-ci.
  \begin{sol}
    Premier ensemble de réponses avec le nombre d'intervalles par
    défaut, soit \nombre{1000} dans nos fonctions.
<<echo=TRUE>>=
pointmilieu(dnorm, 0, 1)
trapeze(dnorm, 0, 1)
simpson(dnorm, 0, 1)
simpson38(dnorm, 0, 1)
mean(dnorm(runif(100000)))
integrate(dnorm, 0, 1)
pnorm(1) - pnorm(0)
@
    Les réponses sont essentiellement identiques. Pour constater des
    différences entre les méthodes d'intégration, il faut réduire le
    nombre d'intervalles. On voit alors que les méthodes de Simpson
    sont plus précises.
<<echo=TRUE>>=
pointmilieu(dnorm, 0, 1, subdiv = 100)
trapeze(dnorm, 0, 1, subdiv = 100)
simpson(dnorm, 0, 1, subdiv = 100)
simpson38(dnorm, 0, 1, subdiv = 100)
@
    \end{sol}
\end{exercice}

\begin{rem}
  Les graphiques des figures \ref{fig:integration:methodes} et \ref{fig:integration:grosplan}
  ont été réalisés entièrement dans \textsf{R} avec les fonctions
  \texttt{curve}, \texttt{rect}, \texttt{polygon} et
  \texttt{segments}. Les étiquettes de l'abscisse ont été changées
  avec la fonction \texttt{axis}. Les polynômes d'interpolation de
  Lagrange utilisés dans la méthode de Simpson ont été calculés avec
  la fonction \texttt{poly.calc} du package \texttt{polynom}
  (disponible sur CRAN).
\end{rem}

\newpage

\begin{Filesave}{solutions}
  \setcounter{chapter}{2}
\end{Filesave}



\section{Code informatique}
\label{sec:integration:code}

%\lstinputlisting[firstline=3]{integration_numerique.R}

\vfill

%\input{exercices-integration_numerique}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "methodes_numeriques-partie_3"
%%% coding: utf-8
%%% End:
