\chapter{Intégration numérique}
\label{chap:integration}

\begin{objectifs}
\item Être en mesure de calculer la valeur approximative d’une
  intégrale définie à l’aide des méthodes du point milieu, du trapèze,
  de Simpson et de Simpson 3/8.
\item Avoir une connaissance générale de ce qu'est un polynôme
  d'interpolation de Lagrange et comment il peut servir dans le
  contexte de l'intégration numérique.
\item Être en mesure de développer les formules d'approximation
  composées de chacune des méthodes d'intégration numériques
  présentées dans le chapitre.
\end{objectifs}

<<echo=FALSE>>=
options(width = 60)
@

Il n'est pas rare de devoir calculer l'intégrale d'une fonction qui
n'admet pas de primitive sous forme explicite ou dont la primitive est
très difficile à calculer. Dans de tels cas, l'intégration numérique
permet d'obtenir une approximation --- parfois excellente --- de
l'intégrale cherchée.

Les méthodes d'approximation qui seront étudiées dans ce chapitre
reposent toutes sur le remplacement de la fonction à intégrer par une
«bonne» approximation sur un intervalle donné. Cette approximation
devra évidemment être simple à intégrer, autrement aucun gain n'est
réalisé. Or, quelles fonctions sont simples à intégrer sinon les
polynômes?


\section{Polynômes d'interpolation de Lagrange}
\label{sec:integration:Lagrange}

Un résultat connu en analyse mathématique sous le nom de Théorème
d'approximation de Weierstrass établit que l'on peut faire
l'approximation de toute fonction continue par un polynôme de degré
suffisant. Formellement, soit
\begin{equation*}
  P_n(x) = a_0 + a_1 x + \dots a_{n - 1} x^{n - 1} + a_n x^n
\end{equation*}
un polynôme de degré $n$. Si $f$ est une fonction continue sur un
intervalle $[a, b]$, alors pour tout $\varepsilon > 0$ il existe un
polynôme $P(x)$ tel que
\begin{equation*}
  |f(x) - P(x)| < \varepsilon
\end{equation*}
pour tout $x \in [a, b]$.

La notion d'approximation d'une fonction par un polynôme est beaucoup
utilisée en analyse numérique puisque les polynômes sont simples à
dériver et à intégrer, et que leurs dérivées et intégrales sont
elles-mêmes des polynômes.

Un type de polynôme d'approximation que vous connaissez déjà est le
polynôme (ou développement) de Taylor autour d'un point $x_0$.
Cependant, les polynômes de Taylor sont conçus pour être précis autour
de $x_0$ et non sur tout un intervalle. Dans le contexte de
l'intégration numérique où nous voudrons remplacer la fonction à
intégrer par un polynôme, nous aurons besoin d'une bonne approximation
sur tout le domaine d'intégration.

C'est là qu'interviennent les polynômes d'interpolation de Lagrange.
Soit $x_0$, $x_1, \dots, x_n$ un ensemble de $n + 1$ points distincts
et $f$ une fonction qui passe par ces points (ou \emph{n{\oe}uds}). Le
polynôme d'interpolation de Lagrange de degré $n$ de la fonction $f$
est
\begin{equation*}
  P_n(x) = f(x_0) L_0(x) + f(x_1) L_1(x) + \dots + f(x_n) L_n(x) =
  \sum_{k = 0}^n f(x_k) L_k(x),
\end{equation*}
où
\begin{align*}
  L_k(x)
  &= \frac{(x - x_0)(x - x_1) \cdots
    (x - x_{k - 1})(x - x_{k +  1}) \cdots (x - x_n)}{%
    (x_k - x_0)(x_k - x_1) \cdots
    (x_k - x_{k - 1})(x_k - x_{k +  1}) \cdots (x_k - x_n)} \\
  &= \prod_{\substack{i = 0 \\ i \neq k}}^n \frac{(x - x_i)}{(x_k - x_i)}.
\end{align*}
Remarquer que le terme $(x - x_k)$ n'apparait pas au numérateur de la
fonction $L_k(x)$.

On peut démontrer \citep[voir, par exemple,][]{Burden:numerical:2011}
que le polynôme $P(x)$ peut être aussi près que l'on veut de la
fonction $f(x)$.

\begin{exemple}
  \label{ex:integration:Lagrange}
  Le polynôme d'interpolation de Lagrange de premier degré de la
  fonction $f$ est
  \begin{align*}
    P_1(x)
    &= f(x_0) L_0(x) + f(x_1) L_1(x) \\
    &= f(x_0) \frac{(x - x_1)}{(x_0 - x_1)}
    + f(x_1) \frac{(x - x_0)}{(x_1 - x_0)}.
  \end{align*}
  Le polynôme de second degré, quant à lui, est
  \begin{align*}
    P_2(x)
    &= f(x_0) L_0(x) + f(x_1) L_1(x) + f(x_2) L_2(x)\\
    &= f(x_0) \frac{(x - x_1)(x - x_2)}{(x_0 - x_1)(x_0 - x_2)}
    + f(x_1) \frac{(x - x_0)(x - x_2)}{(x_1 - x_0)(x_1 - x_2)} \\
    &\phantom{=}
    + f(x_2) \frac{(x - x_0)(x - x_1)}{(x_2 - x_0)(x_2 - x_1)}.
  \end{align*}

  Supposons que $f(x) = 1/x$ et que les polynômes d'interpolation
  passent par les n{\oe}uds $x_0 = 2$, $x_1 = 2,75$ et $x_2 = 4$.
  On a alors
  \begin{align*}
    P_1(x)
    &= \frac{1}{2} \frac{(x - 2,75)}{2 - 2,75}
    + \frac{1}{2,75} \frac{(x - 2)}{(2,75 - 2)} \\
    &= -\frac{2}{3} (x - 2,75) + \frac{16}{33} (x - 2) \\
    &= -\frac{6}{33}\, x + \frac{171}{198} \\
    \intertext{et}
    P_2(x)
    &= \frac{1}{2} \frac{(x - 2,75)(x - 4)}{(2 - 2,75)(2 - 4)}
    + \frac{1}{2,75} \frac{(x - 2)(x - 4)}{(2,75 - 2)(2,75 - 4)} \\
    &\phantom{=}
    + \frac{1}{4} \frac{(x - 2)(x - 2,75)}{(4 - 2)(4 - 2,75)} \\
    &= \frac{1}{3} (x - 2,75)(x - 4)
    - \frac{64}{165} (x - 2)(x - 4)
    + \frac{1}{10} (x - 2)(x - 2,75) \\
    &= \frac{1}{22}\, x^2 - \frac{35}{88}\, x + \frac{49}{44}.
  \end{align*}
  Des approximations de $f(3) = 1/3$ sont donc $P_1(3) \approx
  0,31818$ et $P_2(x) \approx 0,32955$. %
  \qed
\end{exemple}

\begin{gotoR}
  La fonction \code{poly.calc} du package \pkg{polynom} permet de
  calculer le polynôme d'interpolation de Lagrange de degré $n$ dans
  R. Exécuter le code informatique de la
  section~\ref{sec:integration:code} correspondant à ce bloc de
  matière pour vérifier les calculs de
  l'exemple~\ref{ex:integration:Lagrange}.
\end{gotoR}


\section{Principes généraux d'intégration numérique}
\label{sec:integration:principes}

Supposons que l'on cherche à calculer $\int_a^b f(x)\, dx$. Toutes les
méthodes d'intégration numérique reposent, en premier lieu, sur le
découpage du domaine $(a, b)$ en $n$ intervalles. Cela permet
d'évaluer l'intégrale comme une somme d'intégrales sur chacun de ces
intervalles:
\begin{equation*}
  \int_a^b f(x)\, dx = \sum_{j=0}^{n-1} \int_{x_j}^{x_{j+1}} f(x)\, dx.
\end{equation*}
Les diverses méthodes d'intégration numérique diffèrent par la suite
essentiellement par l'approximation de la fonction $f(x)$ sur
l'intervalle $(x_j, x_{j+1})$ utilisée afin de rendre l'intégrale
$\int_{x_j}^{x_{j+1}} f(x)\, dx$ simple à calculer.

La figure~\ref{fig:integration:methodes} illustre les procédures
d'approximation de quatre méthodes courantes d'intégration numérique.

<<echo=FALSE>>=
### Définition de la fonction.
f <- function(x)
{
    x <- (x + 0.2)/1.5
    (dgamma(x, 1.2, 0.5) + dgamma(x, 5, 1))/2 - 0.12
}
@

\SweaveOpts{height=4, width=4}
\begin{figure}[tp]
  \begin{minipage}[t]{0.48\linewidth}
    \centering
<<echo=FALSE, fig=TRUE, results=hide>>=
### Graphique avec point milieu.
par(mar = c(4, 3, 2, 2))
curve(f, xlim = c(0, 6), lwd = 3,
      axes = FALSE, xlab = "", ylab = "")
rect(xleft = 0:5, ybottom = 0, xright = 1:6, ytop = f(1:6 - 0.5),
     density = 5, col = "blue", border = "blue")
axis(1, at = 0:6,
     labels = parse(text = c("a", paste("x[", 1:5*2, "]", sep = ""), "b")))
axis(2)
box()
@
    \subcaption{point milieu \label{fig:integration:methodes:pointmilieu}}
  \end{minipage}
  \begin{minipage}[t]{0.48\linewidth}
    \centering
<<echo = FALSE, fig=TRUE, results=hide>>=
### Graphique avec trapèze
par(mar = c(4, 3, 2, 2))
curve(f, xlim = c(0, 6), lwd = 3,
      axes = FALSE, xlab = "", ylab = "")
x <- 0:6
xx <- c(0, x, 6)
yy <- c(0, f(x), 0)
polygon(xx, yy, density = 5, col = "blue", border = "blue")
segments(x, 0, x, f(x), col = "blue")
axis(1, at = 0:6,
     labels = parse(text = c("a", paste("x[", 1:5, "]", sep = ""), "b")))
axis(2)
box()
@
    \subcaption{trapèze \label{fig:integration:methodes:trapeze}}
  \end{minipage}
  \newline
  \begin{minipage}[t]{0.48\linewidth}
    \centering
<<echo=FALSE, fig=TRUE, results=hide>>=
### Graphique avec Simpson.
## Calcul des polynômes d'interpolation par intervalle.
library(polynom)
x0 <- matrix(c(0:2, 2:4, 4:6, 6:8, 8:10, 10:12)/2, nrow = 3)
y0 <- f(x0)
P2.1 <- poly.calc(x0[,1], y0[,1])
P2.2 <- poly.calc(x0[,2], y0[,2])
P2.3 <- poly.calc(x0[,3], y0[,3])
P2.4 <- poly.calc(x0[,4], y0[,4])
P2.5 <- poly.calc(x0[,5], y0[,5])
P2.6 <- poly.calc(x0[,6], y0[,6])

## Polynôme d'interpolation global.
h <- function(x)
{
    f <- function(x) eval(parse(text = paste("predict(P2.", min(floor(x+1), 6), ", x)", sep = "")))
    sapply(x, f)
}

## Graphique.
xx <- c(0, seq(0, 6, by = 0.01), 6)
yy <- c(0, h(seq(0, 6, by = 0.01)), 0)
par(mar = c(4, 3, 2, 2))
curve(f, xlim = c(0, 6), lwd = 3,
      axes = FALSE, xlab = "", ylab = "")
polygon(xx, yy, density = 5, col = "blue", border = "blue")
segments(x, 0, x, f(x), col = "blue")
axis(1, at = 0:6,
     labels = parse(text = c("a", paste("x[", 1:5, "]", sep = ""), "b")))
axis(2)
box()
@
    \subcaption{Simpson \label{fig:integration:methodes:simpson}}
  \end{minipage}
  \begin{minipage}[t]{0.48\linewidth}
    \centering
<<echo=FALSE, fig=TRUE, results=hide>>=
### Graphique avec Simpson 3/8.
## Calcul des polynômes d'interpolation par intervalle.
x0 <- matrix(c(0:3, 3:6, 6:9, 9:12, 12:15, 15:18)/3, nrow = 4)
y0 <- f(x0)
P3.1 <- poly.calc(x0[,1], y0[,1])
P3.2 <- poly.calc(x0[,2], y0[,2])
P3.3 <- poly.calc(x0[,3], y0[,3])
P3.4 <- poly.calc(x0[,4], y0[,4])
P3.5 <- poly.calc(x0[,5], y0[,5])
P3.6 <- poly.calc(x0[,6], y0[,6])

## Polynôme d'interpolation global.
h <- function(x)
{
    f <- function(x) eval(parse(text = paste("predict(P3.", min(floor(x+1), 6), ", x)", sep = "")))
    sapply(x, f)
}

## Graphique.
xx <- c(0, seq(0, 6, by = 0.01), 6)
yy <- c(0, h(seq(0, 6, by = 0.01)), 0)
par(mar = c(4, 3, 2, 2))
curve(f, xlim = c(0, 6), lwd = 3,
      axes = FALSE, xlab = "", ylab = "")
polygon(xx, yy, density = 5, col = "blue", border = "blue")
segments(x, 0, x, f(x), col = "blue")
axis(1, at = 0:6,
     labels = parse(text = c("a", paste("x[", 1:5, "]", sep = ""), "b")))
axis(2)
box()
@
    \subcaption{Simpson 3/8 \label{fig:integration:methodes:simpson38}}
  \end{minipage}
  \caption{Comparaison de quatre méthodes d'intégration numérique}
  \label{fig:integration:methodes}
\end{figure}

Les formules d'intégration numérique présentées dans la suite
découlent de la procédure suivante: le domaine d'intégration $(a, b)$
est découpé en $n$ intervalles de longueur égale. Chacun de ces
intervalles est à son tour divisé en $m$ sous-intervalles de longueur
égale, pour un total de $nm$ points. On a alors
\begin{align*}
  \int_a^b f(x)\, dx
  &= \int_{x_0}^{x_m} f(x)\, dx
  + \int_{x_m}^{x_{2m}} f(x)\, dx + \dotsi
  + \int_{x_{(n-1)m}}^{x_{nm}} f(x)\, dx \\
  &= \sum_{j=0}^{n - 1} \int_{x_{jm}}^{x_{(j+1)m}} f(x)\, dx,
\end{align*}
où $x_0 = a$ et $x_{nm} = b$. L'approximation numérique se trouve dans
l'évaluation de l'intégrale du côté droit de la dernière équation.
Pour toutes les méthodes étudiées dans ce chapitre sauf la méthode du
point milieu, la fonction $f$ sera remplacée par un polynôme
d'interpolation de Lagrange.

Afin de ne pas alourdir inutilement la notation, les formules
d'approximation de l'intégrale
\begin{equation*}
  \int_{x_{jm}}^{x_{(j+1)m}} f(x)\, dx
\end{equation*}
seront présentées pour le cas $j = 0$ seulement dans les sections
suivantes.


\section{Méthode du point milieu}
\label{sec:integration:pointmilieu}

La méthode du point milieu est la plus simple et la plus intuitive
méthode d'intégration numérique. Les intervalles sont divisés en $m =
2$ parties et la valeur de la fonction $f$ sur l'intervalle $(x_0,
x_2)$ est estimée par $f(x_1)$
(figure~\ref{fig:integration:grosplan:pointmilieu}). Ainsi, on a
l'approximation
\begin{displaymath}
  \int_{x_0}^{x_2} f(x)\, dx \approx 2 h f(x_1),
\end{displaymath}
où $h = x_2 - x_1 = x_1 - x_0$.

La formule composée pour l'approximation par la méthode du point
milieu de $\int_a^b f(x)\, dx$ avec $n$ intervalles est
\begin{displaymath}
  \int_a^b f(x)\, dx \approx 2 h \sum_{j=0}^{n - 1} f(x_{2j + 1})
\end{displaymath}
où $h = (b - a)/(2 n)$ et $x_j = a + jh$.


\section{Méthode du trapèze}
\label{sec:integration:trapeze}

Les trois prochaines méthodes d'intégration numérique sont basées sur
l'approximation de la fonction $f$ sur un intervalle par un polynôme
d'interpolation de Lagrange de degré $m$.

La méthode du trapèze utilise un polynôme du premier degré ($m = 1$)
pour faire l'approximation de la valeur de $f(x)$ sur l'intervalle
$(x_0, x_1)$, ce qui est équivalent à une simple interpolation
linéaire (figure~\ref{fig:integration:grosplan:trapeze}). On a donc
\begin{equation*}
  \int_{x_0}^{x_1} f(x)\, dx \approx  \frac{h}{2}[f(x_0) + f(x_1)],
\end{equation*}
où $h = x_1 - x_0$. Contrairement à ce que peut laisser croire la
figure \ref{fig:integration:methodes}, cette méthode est généralement
plus précise que la méthode du point milieu.

La formule composée pour l'approximation de $\int_a^b f(x)\, dx$ par
la méthode du trapèze avec $n$ intervalles est
\begin{equation*}
  \int_a^b f(x)\, dx \approx \frac{h}{2}
  \left[
    f(a) + f(b) + 2 \sum_{j = 1}^{n - 1} f(x_j)
  \right],
\end{equation*}
où $h = (b - a)/n$ et $x_j = a + jh$.

\begin{figure}[t]
  \begin{minipage}[t]{0.48\linewidth}
    \centering
<<echo=FALSE, fig=TRUE, results=hide>>=
### Gros plan sur point milieu.
g <- function(x) f(3.5 * x + 1.5)
par(mar = c(3, 0, 0, 0))
curve(g, xlim = c(0, 1), lwd = 3, ylim = c(0.020, 0.035),
      axes = FALSE, xlab = "", ylab = "")
lines(c(0, 1), rep(g(0.5), 2), col = "blue")
points(0.5, g(0.5), pch = 16, col = "blue", cex = 1.5)
axis(1, at = c(0, 0.5, 1),
     labels = expression(x[0], x[1], x[2]))
@
  \subcaption{point milieu \label{fig:integration:grosplan:pointmilieu}}
  \end{minipage}
  \begin{minipage}[t]{0.48\linewidth}
    \centering
<<echo = FALSE, fig=TRUE, results=hide>>=
### Gros plan sur trapèze.
par(mar = c(3, 0, 0, 0))
curve(g, xlim = c(0, 1), lwd = 3, ylim = c(0.020, 0.035),
      axes = FALSE, xlab = "", ylab = "")
lines(0:1, g(0:1), col = "blue")
points(0:1, g(0:1), pch = 16, col = "blue", cex = 1.5)
axis(1, at = c(0, 1), labels = parse(text = c("x[0]", "x[1]")))
@
  \subcaption{trapèze \label{fig:integration:grosplan:trapeze}}
  \end{minipage}
  \newline
  \begin{minipage}[t]{0.48\linewidth}
    \centering
<<echo=FALSE, fig=TRUE, results=hide>>=
### Gros plan sur Simpson.
x0 <- seq(0, 1, by = 0.5)
y0 <- g(x0)
P2 <- poly.calc(x0, y0)
h <- function(x) predict(P2, x)
par(mar = c(3, 0, 0, 0))
curve(g, xlim = c(0, 1), lwd = 3, ylim = c(0.020, 0.035),
      axes = FALSE, xlab = "", ylab = "")
curve(h, xlim = c(0, 1), add = TRUE, col = "blue")
points(x0, y0, pch = 16, col = "blue", cex = 1.5)
axis(1, at = c(0, 0.5, 1), labels = parse(text = c("x[0]", "x[1]", "x[2]")))
@
  \subcaption{Simpson \label{fig:integration:grosplan:simpson}}
  \end{minipage}
  \begin{minipage}[t]{0.48\linewidth}
    \centering
<<echo=FALSE, fig=TRUE, results=hide>>=
### Gros plan sur Simpson 3/8.
x0 <- seq(0, 1, by = 1/3)
y0 <- g(x0)
P3 <- poly.calc(x0, y0)
h <- function(x) predict(P3, x)
par(mar = c(3, 0, 0, 0))
curve(g, xlim = c(0, 1), lwd = 3, ylim = c(0.020, 0.035),
      axes = FALSE, xlab = "", ylab = "")
curve(h, xlim = c(0, 1), add = TRUE, col = "blue")
points(x0, y0, pch = 16, col = "blue", cex = 1.5)
axis(1, at = c(0, 1/3, 2/3, 1),
     labels = parse(text = c("x[0]", "x[1]", "x[2]", "x[3]")))
@
  \subcaption{Simpson 3/8 \label{fig:integration:grosplan:simpson38}}
  \end{minipage}
  \caption{Approximation de $f(x)$ sur un intervalle}
  \label{fig:integration:grosplan}
\end{figure}


\section{Méthode de Simpson}
\label{sec:integration:simpson}

La méthode d'approximation de Simpson est la plus usuelle des méthodes
d'intégration numérique, encore que pas nécessairement la plus
précise. La fonction $f(x)$ est remplacée, sur l'intervalle $(x_0,
x_2)$, par un polynôme d'interpolation de Lagrange du second degré
(figure~\ref{fig:integration:grosplan:simpson}). On a donc $m = 2$ et
on peut démontrer que
\begin{equation*}
  \int_{x_0}^{x_2} f(x)\, dx \approx \frac{h}{3}[f(x_0) + 4f(x_1) + f(x_2)],
\end{equation*}
où $h = x_2 - x_1 = x_1 - x_0$. Cette méthode d'approximation
numérique s'avère exacte pour les fonctions polynomiales de degré
trois ou moins.

La formule composée pour l'approximation par la méthode de Simpson de
$\int_a^b f(x)\, dx$ avec $n$ intervalles est
\begin{displaymath}
  \int_a^b f(x)\, dx \approx \frac{h}{3}
  \left[
    f(a) +  2 \sum_{j = 1}^{n - 1} f(x_{2j}) +
    4 \sum_{j = 1}^n f(x_{2j-1}) + f(b)
  \right],
\end{displaymath}
où $h = (b - a)/(2n)$ et $x_j = a + jh$.


\section{Méthode de Simpson 3/8}
\label{sec:integration:simpson38}

La méthode de Simpson 3/8 constitue une extension de la méthode de
Simpson où la fonction $f$ est remplacée par un polynôme
d'interpolation de degré $m = 3$
(figure~\ref{fig:integration:grosplan:simpson38}). On peut alors
démontrer que
\begin{displaymath}
  \int_{x_0}^{x_3} f(x)\, dx \approx \frac{3h}{8}[f(x_0) + 3f(x_1) +
  3f(x_2) + f(x_3)],
\end{displaymath}
où $h = x_3 - x_2 = x_2 - x_1 = x_1 - x_0$. La dérivation de la
formule composée d'approximation de $\int_a^b f(x)\, dx$ avec $n$
intervalles est laissée en exercice.

Consulter \cite{Burden:numerical:2011} pour de plus amples détails sur
les polynômes d'interpolation de Lagrange et les méthodes
d'intégration numérique présentées ci-dessus.

\begin{gotoR}
  Il n'y a pas de fonction dans la distribution de base de R pour le
  calcul d'intégrales avec précisément l'une ou l'autre des méthodes
  mentionnées dans ce chapitre. Cependant, la fonction
  \code{integrate} réalise à peu près la même chose avec un algorithme
  différent. Consulter le code informatique de la
  section~\ref{sec:integration:code} pour quelques menus exemples.
\end{gotoR}

\section{Code informatique}
\label{sec:integration:code}

\lstinputlisting[firstline=3]{integration_numerique.R}

\vfill

\input{exercices-integration_numerique}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "methodes_numeriques-partie_3"
%%% coding: utf-8
%%% End:
